<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><!-- InstanceBegin template="/Templates/frame_content.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<!-- InstanceBeginEditable name="doctitle" -->
<title>Untitled Document</title>
<!-- InstanceEndEditable --> 
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<!-- InstanceBeginEditable name="head" -->
<!-- InstanceEndEditable --> 
<link href="../../css/fc.css" rel="stylesheet" type="text/css">
<style type="text/css">
<!--
.bg {
	background-image: url(../../images/images/main__11.gif);
	background-position: right bottom;
	background-repeat: no-repeat;
	background-attachment: fixed;
}
-->
</style>
</head>

<body >
<table width="100%" height="100%" border="0" cellpadding="4" cellspacing="0">
  <tr>
    <td valign="top"><!-- InstanceBeginEditable name="text" -->
      <table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td><span class="FCcontent">2　近邻函数准则算法<br>
            　　有时会遇到不能确定核函数的形式或不能用简单的函数来表示的情况，此时用上述算法进行聚类就会有困难。图5.8所表示的就是这种情况下，几种具有不同形状数据构造的例子。类似于图5.8表示的情况的一个显著特点，是类内样本具有明显的近邻关系，因而可以利用这种关系，定义近邻函数，以执行动态聚类算法。</span></td>
        </tr>
        <tr> 
          <td align="center"><img src="../../images/image_content/5/5_3066.gif" width="352" height="165"><br>
            <img src="../../images/image_content/5/5_3067.gif" width="202" height="180"> 
            <br>
            <span class="FCcontent">图 5.8 </span></td>
        </tr>
        <tr>
          <td class="FCcontent">　　(1)近邻关系描述<br>
            　　样本集中任何一对样本间的近邻关系可以用彼此是对方的第几个近邻的方式来描述。例如<img src="../../images/image_content/5/yi.gif" width="15" height="14" align="absmiddle">是<img src="../../images/image_content/5/yj.gif" width="15" height="17" align="absmiddle">的第I个近邻，而<img src="../../images/image_content/5/yj.gif" width="15" height="17" align="absmiddle">是<img src="../../images/image_content/5/yi.gif" width="15" height="14" align="absmiddle">的第k个近邻，则这一对样本之间的近邻函数值可定义为(I+K-2)。按此定义的好处是，如一对样本彼此是对方的最近邻，则它们的近邻函数值是零。近邻函数值用<img src="../../images/image_content/5/5_3069.gif" width="19" height="24" align="absmiddle">表示有<br>
            И<img src="../../images/image_content/5/5_3068.gif" width="109" height="37" align="absmiddle"> 
            (5-30)<br>
            　　(2)“连接”损失<br>
            　　用近邻关系进行聚类，可以看作是一种连接过程，即将具有适当近邻关系的样本连接成同一类，而避免在近邻关系较差的样本之间进行连接。为了实现按近邻关系建立样本间的连接关系，可定义一个“连接”损失，在此就以近邻函数值作连接损失值。采用这种定义，可以使连接趋向于发生在距离接近的样本之间。<br>
            　　需要指出的是，为了防止样本自身实行连接，可将<img src="../../images/image_content/5/5_3069.gif" width="19" height="24" align="absmiddle">定义为2N或更大，其中N是样本集的样本数，这种定义是考虑到样本集内任何一对非自身的样本间的最大连接损失为(2N-4)即<br>
             <img src="../../images/image_content/5/5_3070.gif" width="338" height="31" align="absmiddle">　　　　　(5-31)<br>
            　　为了阐明如此定义的连接损失的特点，用图5.9说明以这种定义决定连接关系的例子。图中<img src="../../images/image_content/5/w1.gif" width="18" height="24" align="absmiddle">比较密集，<img src="../../images/image_content/5/w2.gif" width="21" height="23" align="absmiddle">比较稀疏。如果从欧氏距离看<img src="../../images/image_content/5/yi.gif" width="15" height="14" align="absmiddle">似乎应属<img src="../../images/image_content/5/w1.gif" width="18" height="24" align="absmiddle">类，但是从近邻关系来考虑可以看到<img src="../../images/image_content/5/yi.gif" width="15" height="14" align="absmiddle">是<img src="../../images/image_content/5/5_3074.gif" width="17" height="22" align="absmiddle">的6近邻,<img src="../../images/image_content/5/5_3074.gif" width="17" height="22" align="absmiddle">是<img src="../../images/image_content/5/yi.gif" width="15" height="14" align="absmiddle">的1近邻，<img src="../../images/image_content/5/5_3071.gif" width="44" height="28" align="absmiddle">，而<img src="../../images/image_content/5/5_3074.gif" width="17" height="22" align="absmiddle">与<img src="../../images/image_content/5/yi.gif" width="15" height="14" align="absmiddle">间有<img src="../../images/image_content/5/5_3072.gif" width="90" height="27" align="absmiddle">，由此可见按近邻关系<img src="../../images/image_content/5/yi.gif" width="15" height="14" align="absmiddle">应归为<img src="../../images/image_content/5/w2.gif" width="21" height="23" align="absmiddle">类，因其“连接”损失较小。</td>
        </tr>
        <tr>
          <td align="center" class="FCcontent"><img src="../../images/image_content/5/5_3075.gif" width="290" height="207"><br>
            图 5.9 </td>
        </tr>
        <tr> 
          <td>　　<span class="FCcontent">(3)类内损失与类间损失<br>
            　　在定义了连接损失后，就可定义类内损失与类间损失。类内损失定义比较简单，它只是所有连接关系损失总和ИИ<br>
            　　<img src="../../images/image_content/5/5_3076.gif" width="114" height="47" align="absmiddle">　　　　　(5-32)<br>
            　　由于类间不发生连接关系，不存在连接损失，因此<img src="../../images/image_content/5/5_3077.gif" width="26" height="20" align="absmiddle">可以在整个样本集中统计，不需分类统计。<br>
            　　为了统计类间的划分是否合理，需要观察两类间最为接近处的近邻函数值。如果该数值较小，则表示本来很有可能连接起来的近邻没有被“连接”起来，这意味着要冒较大风险，付出较大代价。用定量关系描述，需先定义两类间的最小近邻函数值<img src="../../images/image_content/5/5_3078.gif" width="14" height="27" align="absmiddle">，它是<img src="../../images/image_content/5/w1.gif" width="18" height="24" align="absmiddle">与<img src="../../images/image_content/5/w2.gif" width="21" height="23" align="absmiddle">间各对样本近邻函数值的最小值，而<img src="../../images/image_content/5/w1.gif" width="18" height="24" align="absmiddle">对所有c-1类的最小近邻值r<sub>i</sub>定义为<br>
            　　<img src="../../images/image_content/5/5_3079.gif" width="196" height="45" align="absmiddle">　　　(5-33)<br>
            　　此外还要定义类内最大连接损失，表示为<img src="../../images/image_content/5/5_3080.gif" width="35" height="28" align="absmiddle">，即<img src="../../images/image_content/5/wi.gif" width="19" height="23" align="absmiddle">中各点间连接的最大连接损失值。设<img src="../../images/image_content/5/wi.gif" width="19" height="23" align="absmiddle">与<img src="../../images/image_content/5/wk.gif" width="22" height="22" align="absmiddle">之间具有最小的近邻函数值即<img src="../../images/image_content/5/5_3081.gif" width="44" height="24" align="absmiddle">，则类间的损失显然与r<sub>i</sub>,<img src="../../images/image_content/5/5_3085.gif" width="33" height="25" align="absmiddle">及<img src="../../images/image_content/5/5_3086.gif" width="34" height="23" align="absmiddle">这三者的关系有关，为此定义<img src="../../images/image_content/5/w1.gif" width="18" height="24" align="absmiddle">对其它各类的类间损失为：<br>
             <img src="../../images/image_content/5/5_3084.gif" width="386" height="224" align="absmiddle">　　　(5-34)<br>
            　　该式表明当r<sub>i</sub>比<img src="../../images/image_content/5/5_3085.gif" width="33" height="25" align="absmiddle">及<img src="../../images/image_content/5/5_3086.gif" width="34" height="23" align="absmiddle">都大时，这种类间划分是比较合理的，类间损失为负值，最严重的情况是r<sub>i</sub>比<img src="../../images/image_content/5/5_3085.gif" width="33" height="25" align="absmiddle">及<img src="../../images/image_content/5/5_3086.gif" width="34" height="23" align="absmiddle">都小，这表明类间如此划分要付出较大代价。<br>
            　　总的类间损失定义为<br>
            　　<img src="../../images/image_content/5/5_3087.gif" width="90" height="49" align="absmiddle">　　　(5-35)<br>
            　　显然聚类的结果应使C个类别的类间损失都为负，且希望r<sub>i</sub>尽可能大，而<img src="../../images/image_content/5/5_3085.gif" width="33" height="25" align="absmiddle">及<img src="../../images/image_content/5/5_3086.gif" width="34" height="23" align="absmiddle">则尽可能小。因而准则函数可定义为<br>
            　　<img src="../../images/image_content/5/5_3088.gif" width="114" height="32" align="absmiddle">　　　(5-36)<br>
            　　聚类应使<img src="../../images/image_content/5/5_3089.gif" width="28" height="27" align="absmiddle">为最小，这可用迭代方法实现。由此得出近邻函数准则算法。<br>
            　　(4) 近邻函数准则算法<br>
            　　步骤1 计算距离矩阵D，其元素<br>
            И<img src="../../images/image_content/5/5_3090.gif" width="105" height="31" align="absmiddle"> 
            (5-37)<br>
            　　表示样本<img src="../../images/image_content/5/yi.gif" width="15" height="14" align="absmiddle">与<img src="../../images/image_content/5/yj.gif" width="15" height="17" align="absmiddle">之间的距离。<br>
            　　步骤2 利用矩阵D，确定近邻矩阵M，其元素<img src="../../images/image_content/5/mij.gif" width="24" height="23" align="absmiddle">为样本<img src="../../images/image_content/5/yi.gif" width="15" height="14" align="absmiddle">与<img src="../../images/image_content/5/yj.gif" width="15" height="17" align="absmiddle">的近邻函数值。一般M为正定矩阵。M中元素都为整数。<br>
            　　步骤3 形成近邻函数矩阵L，其元素<br>
            　　<img src="../../images/image_content/5/5_3092.gif" width="121" height="32" align="absmiddle">　　　(5-38)<br>
            　　而L矩阵对角元素<img src="../../images/image_content/5/5_3093.gif" width="43" height="24" align="absmiddle">(或更大)。<br>
            　　步骤4 通过对矩阵L进行搜索，将每个点与和它有最小近邻函数值的点连接起来，从而形成初始聚类。<br>
            　　步骤5 对于在步骤4中所形成的每个类i计算r<sub>i</sub>，并与<img src="../../images/image_content/5/5_3085.gif" width="33" height="25" align="absmiddle">及<img src="../../images/image_content/5/5_3086.gif" width="34" height="23" align="absmiddle">进行比较。若r<sub>i</sub>小于或等于<img src="../../images/image_content/5/5_3085.gif" width="33" height="25" align="absmiddle">及<img src="../../images/image_content/5/5_3086.gif" width="34" height="23" align="absmiddle">中的任何一个，则合并类i和类k，即在这两类中建立“连接”。重复步骤5，直到无这样的“连接”发生为止，程序至此终止。<br>
            </span></td>
        </tr>
      </table>
      <!-- InstanceEndEditable --></td>
  </tr>
</table>
</body>
<!-- InstanceEnd --></html>
