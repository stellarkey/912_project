{
    "status":"ok",
    "knowledge":[
        "管程"
    ],
    "degree_of_difficulty":1,
    "explain":"第1问6分，第2问5分；\n1）命令行状态的键盘输入时的屏幕回显：\n键盘输入产生中断；\n中断处理例程扫描键盘，将数据写入缓冲区；\n并在屏幕回显；\n2）每两个1分；\n    ```\n        // Extract cursor location\n        uint32_t pos;\n        outb(addr_6845, 14);\n        pos = inb(addr_6845 + 1) << 8; / ……(1)……读取光标位置的高8位，并左移8位 /\n        outb(addr_6845, 15);\n        pos |= inb(addr_6845 + 1); / ……(2)……读取光标位置的低8位，并与高8位合并在一个16位 /\n        crt_buf = (uint16_t) cp;\t/ ……(3)……读取显示缓存区起始地址 /\n        crt_pos = pos;\n            if (c != 0) {\n                cons.buf[cons.wpos ++] = c;\t/ ……(4)……键盘输入保存到缓冲区对应的位置，并指针加1 /\n                if (cons.wpos == CONSBUFSIZE) {\n                    cons.wpos = 0; \t/ ……(5)……缓冲区写指针位置移回缓冲区开始地址 /\n        shift |= shiftcode[data]; / ……(6)……依据控制键码表得到控制键编码 /\n        shift ^= togglecode[data];\n        c = charcode[shift & (CTL | SHIFT)][data];\n        if (shift & CAPSLOCK) {\n            if ('a' <= c && c <= 'z')\n                c += 'A' - 'a';\t/ ……(7)……小写字符编码转在大写字符 /\n            else if ('A' <= c && c <= 'Z')\n                c += 'a' - 'A';\n        }\n    void\n    kbd_intr(void) {\n        cons_intr(kbd_proc_data);\t/ ……(8)……从键盘输入并保存到输入缓冲区 /\n    }\n            if (cons.rpos != cons.wpos) {\n                c = cons.buf[cons.rpos ++];\t/ ……(9)……从输入缓冲区读取输入字符编码，并后移读出指针 /\n                if (cons.rpos == CONSBUFSIZE) {\n                    cons.rpos = 0;\t/ ……(10)……将缓冲区读出指针移到缓冲区开头 /\n                }\n            }\n    ```\n\n",
    "question":"(11分)I/O子系统是操作系统中负责计算机系统与外界进行信息交互功能。键盘和显示器是计算机系统中最基本的I/O设备。\n1）试描述ucore内核中是如何实现命令行状态的键盘输入时屏幕回显的；\n2）试解释下面与I/O子系统中指定代码行的作用。注意：需要解释的代码共有10处。\n    ```\n\t    kern-ucore/arch/i386/driver/console.c\n\t    ============ kern-ucore/arch/i386/driver/console.c=================\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    / stupid I/O delay routine necessitated by historical PC design flaws /\n\t    static void\n\t    delay(void) {\n\t        inb(0x84);\n\t        inb(0x84);\n\t        inb(0x84);\n\t        inb(0x84);\n\t    }\n\t    ......\n\t    static uint16_t crt_buf;\n\t    static uint16_t crt_pos;\n\t    static uint16_t addr_6845;\n\t    / TEXT-mode CGA/VGA display output /\n\t    static void\n\t    cga_init(void) {\n\t        volatile uint16_t cp = (uint16_t )(CGA_BUF + KERNBASE);\n\t        uint16_t was = cp;\n\t        cp = (uint16_t) 0xA55A;\n\t        if (cp != 0xA55A) {\n\t            cp = (uint16_t)(MONO_BUF + KERNBASE);\n\t            addr_6845 = MONO_BASE;\n\t        } else {\n\t            cp = was;\n\t            addr_6845 = CGA_BASE;\n\t        }\n\t        // Extract cursor location\n\t        uint32_t pos;\n\t        outb(addr_6845, 14);\n\t        pos = inb(addr_6845 + 1) << 8; / ……(1)…… /\n\t        outb(addr_6845, 15);\n\t        pos |= inb(addr_6845 + 1); / ……(2)…… /\n\t        crt_buf = (uint16_t) cp;\t/ ……(3)…… /\n\t        crt_pos = pos;\n\t    }\n\t    static bool serial_exists = 0;\n\t    static void\n\t    serial_init(void) {\n\t    ......\n\t    }\n\t    ......\n\t    / cga_putc - print character to console /\n\t    static void\n\t    cga_putc(int c) {\n\t        // set black on white\n\t        if (!(c & ~0xFF)) {\n\t            c |= 0x0700;\n\t        }\n\t        switch (c & 0xff) {\n\t        case '\b':\n\t            if (crt_pos > 0) {\n\t                crt_pos --;\n\t                crt_buf[crt_pos] = (c & ~0xff) | ' ';\n\t            }\n\t            break;\n\t        case '\n\t':\n\t            crt_pos += CRT_COLS;\n\t        case '\r':\n\t            crt_pos -= (crt_pos % CRT_COLS);\n\t            break;\n\t        default:\n\t            crt_buf[crt_pos ++] = c;     // write the character\n\t            break;\n\t        }\n\t        // What is the purpose of this?\n\t        if (crt_pos >= CRT_SIZE) {\n\t            int i;\n\t            memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS)  sizeof(uint16_t));\n\t            for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i ++) {\n\t                crt_buf[i] = 0x0700 | ' ';\n\t            }\n\t            crt_pos -= CRT_COLS;\n\t        }\n\t        // move that little blinky thing\n\t        outb(addr_6845, 14);\n\t        outb(addr_6845 + 1, crt_pos >> 8);\n\t        outb(addr_6845, 15);\n\t        outb(addr_6845 + 1, crt_pos);\n\t    }\n\t    ......\n\t    / \n\t      Here we manage the console input buffer, where we stash characters\n\t      received from the keyboard or serial port whenever the corresponding\n\t      interrupt occurs.\n\t      /\n\t    #define CONSBUFSIZE 512\n\t    static struct {\n\t        uint8_t buf[CONSBUFSIZE];\n\t        uint32_t rpos;\n\t        uint32_t wpos;\n\t    } cons;\n\t    / \n\t      cons_intr - called by device interrupt routines to feed input\n\t      characters into the circular console input buffer.\n\t      /\n\t    static void\n\t    cons_intr(int (proc)(void)) {\n\t        int c;\n\t        while ((c = (proc)()) != -1) {\n\t            if (c != 0) {\n\t                cons.buf[cons.wpos ++] = c;\t/ ……(4)…… /\n\t                if (cons.wpos == CONSBUFSIZE) {\n\t                    cons.wpos = 0; \t/ ……(5)…… /\n\t                }\n\t            }\n\t        }\n\t    }\n\t    / serial_proc_data - get data from serial port /\n\t    static int\n\t    serial_proc_data(void) {\n\t        if (!(inb(COM1 + COM_LSR) & COM_LSR_DATA)) {\n\t            return -1;\n\t        }\n\t        int c = inb(COM1 + COM_RX);\n\t        if (c == 127) {\n\t            c = '\b';\n\t        }\n\t        return c;\n\t    }\n\t    / serial_intr - try to feed input characters from serial port /\n\t    void\n\t    serial_intr(void) {\n\t        if (serial_exists) {\n\t            cons_intr(serial_proc_data);\n\t        }\n\t    }\n\t    / Keyboard input code /\n\t    #define NO              0\n\t    #define SHIFT           (1<<0)\n\t    #define CTL             (1<<1)\n\t    #define ALT             (1<<2)\n\t    #define CAPSLOCK        (1<<3)\n\t    #define NUMLOCK         (1<<4)\n\t    #define SCROLLLOCK      (1<<5)\n\t    #define E0ESC           (1<<6)\n\t    static uint8_t shiftcode[256] = {\n\t        [0x1D] CTL,\n\t        [0x2A] SHIFT,\n\t        [0x36] SHIFT,\n\t        [0x38] ALT,\n\t        [0x9D] CTL,\n\t        [0xB8] ALT\n\t    };\n\t    static uint8_t togglecode[256] = {\n\t        [0x3A] CAPSLOCK,\n\t        [0x45] NUMLOCK,\n\t        [0x46] SCROLLLOCK\n\t    };\n\t    static uint8_t normalmap[256] = {\n\t        NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  // 0x00\n\t        '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',\n\t        'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  // 0x10\n\t        'o',  'p',  '[',  ']',  '\n\t', NO,   'a',  's',\n\t        'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  // 0x20\n\t        '\\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',\n\t        'b',  'n',  'm',  ',',  '.',  '/',  NO,   '',  // 0x30\n\t        NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,\n\t        NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40\n\t        '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',\n\t        '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50\n\t        [0xC7] KEY_HOME,    [0x9C] '\n\t' /KP_Enter/,\n\t        [0xB5] '/' /KP_Div/,  [0xC8] KEY_UP,\n\t        [0xC9] KEY_PGUP,    [0xCB] KEY_LF,\n\t        [0xCD] KEY_RT,      [0xCF] KEY_END,\n\t        [0xD0] KEY_DN,      [0xD1] KEY_PGDN,\n\t        [0xD2] KEY_INS,     [0xD3] KEY_DEL\n\t    };\n\t    static uint8_t shiftmap[256] = {\n\t        NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  // 0x00\n\t        '&',  '',  '(',  ')',  '_',  '+',  '\b', '\t',\n\t        'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  // 0x10\n\t        'O',  'P',  '{',  '}',  '\n\t', NO,   'A',  'S',\n\t        'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  // 0x20\n\t        '\"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',\n\t        'B',  'N',  'M',  '<',  '>',  '?',  NO,   '',  // 0x30\n\t        NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,\n\t        NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  // 0x40\n\t        '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',\n\t        '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   // 0x50\n\t        [0xC7] KEY_HOME,    [0x9C] '\n\t' /KP_Enter/,\n\t        [0xB5] '/' /KP_Div/,  [0xC8] KEY_UP,\n\t        [0xC9] KEY_PGUP,    [0xCB] KEY_LF,\n\t        [0xCD] KEY_RT,      [0xCF] KEY_END,\n\t        [0xD0] KEY_DN,      [0xD1] KEY_PGDN,\n\t        [0xD2] KEY_INS,     [0xD3] KEY_DEL\n\t    };\n\t    #define C(x) (x - '@')\n\t    static uint8_t ctlmap[256] = {\n\t        NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,\n\t        NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,\n\t        C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),\n\t        C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),\n\t        C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,\n\t        NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),\n\t        C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,\n\t        [0x97] KEY_HOME,\n\t        [0xB5] C('/'),      [0xC8] KEY_UP,\n\t        [0xC9] KEY_PGUP,    [0xCB] KEY_LF,\n\t        [0xCD] KEY_RT,      [0xCF] KEY_END,\n\t        [0xD0] KEY_DN,      [0xD1] KEY_PGDN,\n\t        [0xD2] KEY_INS,     [0xD3] KEY_DEL\n\t    };\n\t    static uint8_t charcode[4] = {\n\t        normalmap,\n\t        shiftmap,\n\t        ctlmap,\n\t        ctlmap\n\t    };\n\t    / \n\t      kbd_proc_data - get data from keyboard\n\t     \n\t      The kbd_proc_data() function gets data from the keyboard.\n\t      If we finish a character, return it, else 0. And return -1 if no data.\n\t      /\n\t    static int\n\t    kbd_proc_data(void) {\n\t        int c;\n\t        uint8_t data;\n\t        static uint32_t shift;\n\t        if ((inb(KBSTATP) & KBS_DIB) == 0) {\n\t            return -1;\n\t        }\n\t        data = inb(KBDATAP);\n\t        if (data == 0xE0) {\n\t            // E0 escape character\n\t            shift |= E0ESC;\n\t            return 0;\n\t        } else if (data & 0x80) {\n\t            // Key released\n\t            data = (shift & E0ESC ? data : data & 0x7F);\n\t            shift &= ~(shiftcode[data] | E0ESC);\n\t            return 0;\n\t        } else if (shift & E0ESC) {\n\t            // Last character was an E0 escape; or with 0x80\n\t            data |= 0x80;\n\t            shift &= ~E0ESC;\n\t        }\n\t        shift |= shiftcode[data]; / ……(6)…… /\n\t        shift ^= togglecode[data];\n\t        c = charcode[shift & (CTL | SHIFT)][data];\n\t        if (shift & CAPSLOCK) {\n\t            if ('a' <= c && c <= 'z')\n\t                c += 'A' - 'a';\t/ ……(7)…… /\n\t            else if ('A' <= c && c <= 'Z')\n\t                c += 'a' - 'A';\n\t        }\n\t        // Process special keys\n\t        // Ctrl-Alt-Del: reboot\n\t        if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {\n\t            kprintf(\"Rebooting!\n\t\");\n\t            outb(0x92, 0x3); // courtesy of Chris Frost\n\t        }\n\t        return c;\n\t    }\n\t    / kbd_intr - try to feed input characters from keyboard /\n\t    void\n\t    kbd_intr(void) {\n\t        cons_intr(kbd_proc_data);\t/ ……(8)…… /\n\t    }\n\t    static void\n\t    kbd_init(void) {\n\t        // drain the kbd buffer\n\t        kbd_intr();\n\t        pic_enable(IRQ_KBD);\n\t    }\n\t    / cons_init - initializes the console devices /\n\t    void\n\t    cons_init(void) {\n\t        cga_init();\n\t        serial_init();\n\t        kbd_init();\n\t        if (!serial_exists) {\n\t            kprintf(\"serial port does not exist!!\n\t\");\n\t        }\n\t    }\n\t    / cons_putc - print a single character @c to console devices /\n\t    void\n\t    cons_putc(int c) {\n\t        bool intr_flag;\n\t        local_intr_save(intr_flag);\n\t        {\n\t            lpt_putc(c);\n\t            cga_putc(c);\n\t            serial_putc(c);\n\t        }\n\t        local_intr_restore(intr_flag);\n\t    }\n\t    / \n\t      cons_getc - return the next input character from console,\n\t      or 0 if none waiting.\n\t      /\n\t    int\n\t    cons_getc(void) {\n\t        int c = 0;\n\t        bool intr_flag;\n\t        local_intr_save(intr_flag);\n\t        {\n\t            // poll for any pending input characters,\n\t            // so that this function works even when interrupts are disabled\n\t            // (e.g., when called from the kernel monitor).\n\t            serial_intr();\n\t            kbd_intr();\n\t            // grab the next character from the input buffer.\n\t            if (cons.rpos != cons.wpos) {\n\t                c = cons.buf[cons.rpos ++];\t/ ……(9)…… /\n\t                if (cons.rpos == CONSBUFSIZE) {\n\t                    cons.rpos = 0;\t/ ……(10)…… /\n\t                }\n\t            }\n\t        }\n\t        local_intr_restore(intr_flag);\n\t        return c;\n\t    }\n\t    =============================================================\n\t    ```\n    \n",
    "source":"网络",
    "answer":"第1问6分，第2问5分；\n1）命令行状态的键盘输入时的屏幕回显：\n键盘输入产生中断；\n中断处理例程扫描键盘，将数据写入缓冲区；\n并在屏幕回显；\n2）每两个1分；\n    ```\n        // Extract cursor location\n        uint32_t pos;\n        outb(addr_6845, 14);\n        pos = inb(addr_6845 + 1) << 8; / ……(1)……读取光标位置的高8位，并左移8位 /\n        outb(addr_6845, 15);\n        pos |= inb(addr_6845 + 1); / ……(2)……读取光标位置的低8位，并与高8位合并在一个16位 /\n        crt_buf = (uint16_t) cp;\t/ ……(3)……读取显示缓存区起始地址 /\n        crt_pos = pos;\n            if (c != 0) {\n                cons.buf[cons.wpos ++] = c;\t/ ……(4)……键盘输入保存到缓冲区对应的位置，并指针加1 /\n                if (cons.wpos == CONSBUFSIZE) {\n                    cons.wpos = 0; \t/ ……(5)……缓冲区写指针位置移回缓冲区开始地址 /\n        shift |= shiftcode[data]; / ……(6)……依据控制键码表得到控制键编码 /\n        shift ^= togglecode[data];\n        c = charcode[shift & (CTL | SHIFT)][data];\n        if (shift & CAPSLOCK) {\n            if ('a' <= c && c <= 'z')\n                c += 'A' - 'a';\t/ ……(7)……小写字符编码转在大写字符 /\n            else if ('A' <= c && c <= 'Z')\n                c += 'a' - 'A';\n        }\n    void\n    kbd_intr(void) {\n        cons_intr(kbd_proc_data);\t/ ……(8)……从键盘输入并保存到输入缓冲区 /\n    }\n            if (cons.rpos != cons.wpos) {\n                c = cons.buf[cons.rpos ++];\t/ ……(9)……从输入缓冲区读取输入字符编码，并后移读出指针 /\n                if (cons.rpos == CONSBUFSIZE) {\n                    cons.rpos = 0;\t/ ……(10)……将缓冲区读出指针移到缓冲区开头 /\n                }\n            }\n    ```\n\n",
    "type":"question_answer",
    "q_number":1070
}