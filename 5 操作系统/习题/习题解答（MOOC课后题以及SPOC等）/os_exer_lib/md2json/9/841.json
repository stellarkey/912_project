{"knowledge": "进程间通信。\r\n", "question": "(20140606-期末考试试题&参考答案.docx)IPC\r\n(15分)在具备了执行用户态进程的能力之后，uCore要为这些进程提供的一个重要服务，是用户进程之间的消息传递机制（Inter-Process\r\nCommunication，简写为IPC）。现在，我们要为uCore实现以下两个系统调用，以实现一种同步的IPC机制（暂不考虑超时等功能）：\r\nint sys_send_event(int pid, int event);\r\n参数：pid - 该消息的目标进程的进程号；\r\nevent – 消息内容，用一个整型表示。\r\n返回值：消息成功发送时，返回0；否则，返回相应的错误代码。\r\nint sys_recv_event(int pid, int event);\r\n参数：pid - 函数返回时，pid保存发出消息的进程的进程号，可以为NULL；\r\nevent – 函数返回时，event保存消息内容，可以为NULL。\r\n返回值：消息成功接收时，返回0；否则，返回相应的错误代码。\r\n1）以下是一个基于上述IPC机制求质数的用户程序：\r\n    ```\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    const int total = 1000;\r\n\t    void primeproc(void)\r\n\t    {\r\n\t            int index = 0, this, num, pid = 0;\r\n\t    top:\r\n\t            recv_event(NULL, &this;);\r\n\t            cprintf(\"%d is a primer.\r\n\t\", this);\r\n\t            while (recv_event(NULL, &num;) == 0) {\r\n\t                    if ((num % this) == 0) {\r\n\t                            continue;\r\n\t                    }\r\n\t                    if (pid == 0) {\r\n\t                            if (index + 1 == total) {\r\n\t                                    goto out;\r\n\t                            }\r\n\t                            if ((pid = fork()) == 0) {\r\n\t                                    index++;\r\n\t                                    goto top;\r\n\t                            }\r\n\t                            if (pid < 0) {\r\n\t                                    goto out;\r\n\t                            }\r\n\t                    }\r\n\t                    if (send_event(pid, num) != 0) {\r\n\t                            goto out;\r\n\t                    }\r\n\t            }\r\n\t    out:\r\n\t            cprintf(\"[%04d] %d quit.\r\n\t\", getpid(), index);\r\n\t    }\r\n\t    int main(void)\r\n\t    {\r\n\t            int i, pid;\r\n\t            unsigned int time = gettime_msec();\r\n\t            if ((pid = fork()) == 0) {\r\n\t                    primeproc();\r\n\t                    exit(0);\r\n\t            }\r\n\t            assert(pid > 0);\r\n\t            for (i = 2;; i++) {\r\n\t                    if (send_event(pid, i) != 0) {\r\n\t                            break;\r\n\t                    }\r\n\t            }\r\n\t            cprintf(\"use %d msecs.\r\n\t\", gettime_msec() - time);\r\n\t            cprintf(\"primer3 pass.\r\n\t\");\r\n\t            return 0;\r\n\t    }\r\n\t    ```\r\n简述这个程序是如何判断并输出前五个质数的。\r\n2）给出一种基于等待队列的上述IPC机制的实现方案。  \r\n\r\n", "degree_of_difficulty": "1\r\n", "source": "网络\r\n", "answer": "1）（6分）每个运行primeproc的进程有一个自身编号index，其最多有一个子进程，子进程的编号号为index+1;这样形成了一个子进程链。", "type": "4\r\n", "options": "  \r\n"}