{"knowledge": "启动和中断处理实验。\r\n", "question": "(20140410-2-期中考试试题v4a答案.docx)系统启动\r\n（15分）Bootloader是ucore操作系统启动中的很重要的一部分，Bootloader是由BIOS代码读入内存，然后跳转到它开始执行的。请参考boo\r\ntasm.S和bootmain.c的源代码，回答下列问题：\r\n1) Bootloader包含在硬盘主引导扇区中，硬盘主引导扇区的主要特征有哪些？\r\n2) Bootloader执行的第一条指令是哪一行？Bootloader从实模式进入保护模式后执行的第一条指令是哪一行？为什么要转换到保护模式？\r\n3) Bootloader在完成从硬盘扇区读入ucore内核映像后是如何跳转到ucore内核代码的？\r\n    ```\r\n\t    // =========/libs/elf.h=========\r\n\t    #ifndef __LIBS_ELF_H__\r\n\t    #define __LIBS_ELF_H__\r\n\t    #include\r\n\t    #define ELF_MAGIC    0x464C457FU            // \"\\x7FELF\" in little endian\r\n\t    / file header /\r\n\t    struct elfhdr {\r\n\t        uint32_t e_magic;     // must equal ELF_MAGIC\r\n\t        uint8_t e_elf[12];\r\n\t        uint16_t e_type;      // 1=relocatable, 2=executable, 3=shared object, 4=core image\r\n\t        uint16_t e_machine;   // 3=x86, 4=68K, etc.\r\n\t        uint32_t e_version;   // file version, always 1\r\n\t        uint32_t e_entry;     // entry point if executable\r\n\t        uint32_t e_phoff;     // file position of program header or 0\r\n\t        uint32_t e_shoff;     // file position of section header or 0\r\n\t        uint32_t e_flags;     // architecture-specific flags, usually 0\r\n\t        uint16_t e_ehsize;    // size of this elf header\r\n\t        uint16_t e_phentsize; // size of an entry in program header\r\n\t        uint16_t e_phnum;     // number of entries in program header or 0\r\n\t        uint16_t e_shentsize; // size of an entry in section header\r\n\t        uint16_t e_shnum;     // number of entries in section header or 0\r\n\t        uint16_t e_shstrndx;  // section number that contains section name strings\r\n\t    };\r\n\t    / program section header /\r\n\t    struct proghdr {\r\n\t        uint32_t p_type;   // loadable code or data, dynamic linking info,etc.\r\n\t        uint32_t p_offset; // file offset of segment\r\n\t        uint32_t p_va;     // virtual address to map segment\r\n\t        uint32_t p_pa;     // physical address, not used\r\n\t        uint32_t p_filesz; // size of segment in file\r\n\t        uint32_t p_memsz;  // size of segment in memory (bigger if contains bss）\r\n\t        uint32_t p_flags;  // read/write/execute bits\r\n\t        uint32_t p_align;  // required alignment, invariably hardware page size\r\n\t    };\r\n\t    #endif / !__LIBS_ELF_H__ /\r\n\t    ```\r\n\t    ```\r\n\t    //=========/boot/bootasm.S=========\r\n\t    #include\r\n\t    # Start the CPU: switch to 32-bit protected mode, jump into C.\r\n\t    # The BIOS loads this code from the first sector of the hard disk into\r\n\t    # memory at physical address 0x7c00 and starts executing in real mode\r\n\t    # with %cs=0 %ip=7c00.\r\n\t    .set PROT_MODE_CSEG,        0x8                     # kernel code segment selector\r\n\t    .set PROT_MODE_DSEG,        0x10                    # kernel data segment selector\r\n\t    .set CR0_PE_ON,             0x1                     # protected mode enable flag\r\n\t    # start address should be 0:7c00, in real mode, the beginning address of the running bootloader\r\n\t    .globl start\r\n\t    start:\r\n\t    .code16                                             # Assemble for 16-bit mode\r\n\t        cli                                             # Disable interrupts\r\n\t        cld                                             # String operations increment\r\n\t        # Set up the important data segment registers (DS, ES, SS).\r\n\t        xorw %ax, %ax                                   # Segment number zero\r\n\t        movw %ax, %ds                                   # -> Data Segment\r\n\t        movw %ax, %es                                   # -> Extra Segment\r\n\t        movw %ax, %ss                                   # -> Stack Segment\r\n\t        # Enable A20:\r\n\t        #  For backwards compatibility with the earliest PCs, physical\r\n\t        #  address line 20 is tied low, so that addresses higher than\r\n\t        #  1MB wrap around to zero by default. This code undoes this.\r\n\t    seta20.1:\r\n\t        inb $0x64, %al                                  # Wait for not busy\r\n\t        testb $0x2, %al\r\n\t        jnz seta20.1\r\n\t        movb $0xd1, %al                                 # 0xd1 -> port 0x64\r\n\t        outb %al, $0x64\r\n\t    seta20.2:\r\n\t        inb $0x64, %al                                  # Wait for not busy\r\n\t        testb $0x2, %al\r\n\t        jnz seta20.2\r\n\t        movb $0xdf, %al                                 # 0xdf -> port 0x60\r\n\t        outb %al, $0x60\r\n\t        # Switch from real to protected mode, using a bootstrap GDT\r\n\t        # and segment translation that makes virtual addresses\r\n\t        # identical to physical addresses, so that the\r\n\t        # effective memory map does not change during the switch.\r\n\t        lgdt gdtdesc\r\n\t        movl %cr0, %eax\r\n\t        orl $CR0_PE_ON, %eax\r\n\t        movl %eax, %cr0\r\n\t        # Jump to next instruction, but in 32-bit code segment.\r\n\t        # Switches processor into 32-bit mode.\r\n\t        ljmp $PROT_MODE_CSEG, $protcseg\r\n\t    .code32                                             # Assemble for 32-bit mode\r\n\t    protcseg:\r\n\t        # Set up the protected-mode data segment registers\r\n\t        movw $PROT_MODE_DSEG, %ax                       # Our data segment selector\r\n\t        movw %ax, %ds                                   # -> DS: Data Segment\r\n\t        movw %ax, %es                                   # -> ES: Extra Segment\r\n\t        movw %ax, %fs                                   # -> FS\r\n\t        movw %ax, %gs                                   # -> GS\r\n\t        movw %ax, %ss                                   # -> SS: Stack Segment\r\n\t        # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)\r\n\t        movl $0x0, %ebp\r\n\t        movl $start, %esp\r\n\t        call bootmain\r\n\t        # If bootmain returns (it shouldn't), loop.\r\n\t    spin:\r\n\t        jmp spin\r\n\t    # Bootstrap GDT\r\n\t    .p2align 2                                          # force 4 byte alignment\r\n\t    gdt:\r\n\t        SEG_NULLASM                                     # null seg\r\n\t        SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel\r\n\t        SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel\r\n\t    gdtdesc:\r\n\t        .word 0x17                                      # sizeof(gdt) - 1\r\n\t        .long gdt                                       # address gdt\r\n\t    ```\r\n\t    ```\r\n\t    //=========/boot/bootmain.c=========\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    / \r\n\t      This a dirt simple boot loader, whose sole job is to boot\r\n\t      an ELF kernel image from the first IDE hard disk.\r\n\t     \r\n\t      DISK LAYOUT\r\n\t        This program(bootasm.S and bootmain.c) is the bootloader.\r\n\t         It should be stored in the first sector of the disk.\r\n\t     \r\n\t        The 2nd sector onward holds the kernel image.\r\n\t     \r\n\t        The kernel image must be in ELF format.\r\n\t     \r\n\t      BOOT UP STEPS\r\n\t        when the CPU boots it loads the BIOS into memory and executes it\r\n\t     \r\n\t        the BIOS intializes devices, sets of the interrupt routines, and\r\n\t         reads the first sector of the boot device(e.g., hard-drive)\r\n\t         into memory and jumps to it.\r\n\t     \r\n\t        Assuming this boot loader is stored in the first sector of the\r\n\t         hard-drive, this code takes over...\r\n\t     \r\n\t        control starts in bootasm.S -- which sets up protected mode,\r\n\t         and a stack so C code then run, then calls bootmain()\r\n\t     \r\n\t        bootmain() in this file takes over, reads in the kernel and jumps to it.\r\n\t      /\r\n\t    #define SECTSIZE        512\r\n\t    #define ELFHDR          ((struct elfhdr )0x10000)      // scratch space\r\n\t    / waitdisk - wait for disk ready /\r\n\t    static void\r\n\t    waitdisk(void) {\r\n\t        while ((inb(0x1F7) & 0xC0) != 0x40)\r\n\t            / do nothing /;\r\n\t    }\r\n\t    / readsect - read a single sector at @secno into @dst /\r\n\t    static void\r\n\t    readsect(void dst, uint32_t secno) {\r\n\t        // wait for disk to be ready\r\n\t        waitdisk();\r\n\t        outb(0x1F2, 1);                         // count = 1\r\n\t        outb(0x1F3, secno & 0xFF);\r\n\t        outb(0x1F4, (secno >> 8) & 0xFF);\r\n\t        outb(0x1F5, (secno >> 16) & 0xFF);\r\n\t        outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0);\r\n\t        outb(0x1F7, 0x20);                      // cmd 0x20 - read sectors\r\n\t        // wait for disk to be ready\r\n\t        waitdisk();\r\n\t        // read a sector\r\n\t        insl(0x1F0, dst, SECTSIZE / 4);\r\n\t    }\r\n\t    / \r\n\t      readseg - read @count bytes at @offset from kernel into virtual address @va,\r\n\t      might copy more than asked.\r\n\t      /\r\n\t    static void\r\n\t    readseg(uintptr_t va, uint32_t count, uint32_t offset) {\r\n\t        uintptr_t end_va = va + count;\r\n\t        // round down to sector boundary\r\n\t        va -= offset % SECTSIZE;\r\n\t        // translate from bytes to sectors; kernel starts at sector 1\r\n\t        uint32_t secno = (offset / SECTSIZE) + 1;\r\n\t        // If this is too slow, we could read lots of sectors at a time.\r\n\t        // We'd write more to memory than asked, but it doesn't matter --\r\n\t        // we load in increasing order.\r\n\t        for (; va < end_va; va += SECTSIZE, secno ++) {\r\n\t            readsect((void )va, secno);\r\n\t        }\r\n\t    }\r\n\t    / bootmain - the entry of bootloader /\r\n\t    void\r\n\t    bootmain(void) {\r\n\t        // read the 1st page off disk\r\n\t        readseg((uintptr_t)ELFHDR, SECTSIZE  8, 0);\r\n\t        // is this a valid ELF?\r\n\t        if (ELFHDR->e_magic != ELF_MAGIC) {\r\n\t            goto bad;\r\n\t        }\r\n\t        struct proghdr ph, eph;\r\n\t        // load each program segment (ignores ph flags)\r\n\t        ph = (struct proghdr )((uintptr_t)ELFHDR + ELFHDR->e_phoff);\r\n\t        eph = ph + ELFHDR->e_phnum;\r\n\t        for (; ph < eph; ph ++) {\r\n\t            readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);\r\n\t        }\r\n\t        // call the entry point from the ELF header\r\n\t        // note: does not return\r\n\t        ((void ()(void))(ELFHDR->e_entry & 0xFFFFFF))();\r\n\t    bad:\r\n\t        outw(0x8A00, 0x8A00);\r\n\t        outw(0x8A00, 0x8E00);\r\n\t        / do nothing /\r\n\t        while (1);\r\n\t    }\r\n\t    ```\r\n    \r\n\r\n", "degree_of_difficulty": "1\r\n", "source": "网络\r\n", "answer": "MBR由三部分构成：", "type": "4\r\n", "options": "  \r\n"}