{"knowledge": "连续内存分配。\r\n", "question": "1）试利用图示描述伙伴系统（Buddy System）中对物理内存的分配和回收过程。2）请补全下面伙伴系统实现中所缺的代码。\r\n    ```\r\n\t    =============kern-ucore/arch/i386/mm/buddy_pmm.c=============\r\n\t    // {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024}\r\n\t    // from 2^0 ~ 2^10\r\n\t    #define MAX_ORDER 10\r\n\t    static free_area_t free_area[MAX_ORDER + 1];\r\n\t    //x from 0 ~ MAX_ORDER\r\n\t    #define free_list(x) (free_area[x].free_list)\r\n\t    #define nr_free(x) (free_area[x].nr_free)\r\n\t    #define MAX_ZONE_NUM 10\r\n\t    struct Zone {\r\n\t        struct Page mem_base;\r\n\t    } zones[MAX_ZONE_NUM] = {{NULL}};\r\n\t    //buddy_init - init the free_list(0 ~ MAX_ORDER) & reset nr_free(0 ~ MAX_ORDER)\r\n\t    static void\r\n\t    buddy_init(void) {\r\n\t        int i;\r\n\t        for (i = 0; i <= MAX_ORDER; i ++) {\r\n\t            list_init(&free;_list(i));\r\n\t            nr_free(i) = 0;\r\n\t        }\r\n\t    }\r\n\t    //buddy_init_memmap - build free_list for Page base follow  n continuing pages.\r\n\t    static void\r\n\t    buddy_init_memmap(struct Page base, size_t n) {\r\n\t    ……\r\n\t    }\r\n\t    //getorder - return order, the minmal 2^order >= n\r\n\t    static inline size_t\r\n\t    getorder(size_t n) {\r\n\t        size_t order, order_size;\r\n\t        for (order = 0, order_size = 1; order <= MAX_ORDER; order ++, order_size <<= 1) {\r\n\t            if (n <= order_size) {\r\n\t                return order;\r\n\t            }\r\n\t        }\r\n\t        panic(\"getorder failed. %d\r\n\t\", n);\r\n\t    }\r\n\t    //buddy_alloc_pages_sub - the actual allocation implimentation, return a page whose size >=n,\r\n\t    //                      - the remaining free parts insert to other free list\r\n\t    static inline struct Page \r\n\t    buddy_alloc_pages_sub(size_t order) {\r\n\t        assert(order <= MAX_ORDER);\r\n\t        size_t cur_order;\r\n\t        for (cur_order = order; cur_order <= MAX_ORDER; cur_order ++) {\r\n\t            if (!list_empty(&free;_list(cur_order))) {\r\n\t                list_entry_t le = list_next(&free;_list(cur_order));\r\n\t                struct Page page = le2page(le, page_link);\r\n\t                nr_free(cur_order) --;\r\n\t                _--YOUR CODE 9--_(le);\r\n\t                size_t size = 1 << cur_order;\r\n\t                while (cur_order > order) {\r\n\t                    cur_order --;\r\n\t                    size >>= 1;\r\n\t                    struct Page buddy = page + size;\r\n\t                    buddy->property = cur_order;\r\n\t                    SetPageProperty(buddy);\r\n\t                    nr_free(cur_order) ++;\r\n\t                    _--YOUR CODE 10--_(&free;_list(cur_order), &(buddy->page_link));\r\n\t                }\r\n\t                ClearPageProperty(page);\r\n\t                return page;\r\n\t            }\r\n\t        }\r\n\t        return NULL;\r\n\t    }\r\n\t    //buddy_alloc_pages - call buddy_alloc_pages_sub to alloc 2^order>=n pages\r\n\t    static struct Page \r\n\t    buddy_alloc_pages(size_t n) {\r\n\t        assert(n > 0);\r\n\t        size_t order = getorder(n), order_size = (1 << order);\r\n\t        struct Page page = buddy_alloc_pages_sub(order);\r\n\t        if (page != NULL && n != order_size) {\r\n\t            free_pages(page + n, order_size - n);\r\n\t        }\r\n\t        return page;\r\n\t    }\r\n\t    //page_is_buddy - Does this page belong to the No. zone_num Zone & this page\r\n\t    //              -  be in the continuing page block whose size is 2^order pages?\r\n\t    static inline bool\r\n\t    page_is_buddy(struct Page page, size_t order, int zone_num) {\r\n\t        if (page2ppn(page) < npage) {\r\n\t            if (page->zone_num == zone_num) {\r\n\t                return !PageReserved(page) && PageProperty(page) && page->property == order;\r\n\t            }\r\n\t        }\r\n\t        return 0;\r\n\t    }\r\n\t    //page2idx - get the related index number idx of continuing page block which this page belongs to\r\n\t    static inline ppn_t\r\n\t    page2idx(struct Page page) {\r\n\t        return page - zones[page->zone_num].mem_base;\r\n\t    }\r\n\t    //idx2page - get the related page according to the index number idx of continuing page block\r\n\t    static inline struct Page \r\n\t    idx2page(int zone_num, ppn_t idx) {\r\n\t        return zones[zone_num].mem_base + idx;\r\n\t    }\r\n\t    //buddy_free_pages_sub - the actual free implimentation, should consider how to\r\n\t    //                     - merge the adjacent buddy block\r\n\t    static void\r\n\t    buddy_free_pages_sub(struct Page base, size_t order) {\r\n\t        ppn_t buddy_idx, page_idx = page2idx(base);\r\n\t        assert((page_idx & ((1 << order) - 1)) == 0);\r\n\t        struct Page p = base;\r\n\t        for (; p != base + (1 << order); p ++) {\r\n\t            assert(!PageReserved(p) && !PageProperty(p));\r\n\t            p->flags = 0;\r\n\t            set_page_ref(p, 0);\r\n\t        }\r\n\t        int zone_num = base->zone_num;\r\n\t        while (order < MAX_ORDER) {\r\n\t            buddy_idx = page_idx ^ (1 << order);\r\n\t            struct Page buddy = idx2page(zone_num, buddy_idx);\r\n\t            if (!page_is_buddy(buddy, order, zone_num)) {\r\n\t                break;\r\n\t            }\r\n\t            nr_free(order) --;\r\n\t            _--YOUR CODE 11--_(&(buddy->page_link));\r\n\t            ClearPageProperty(buddy);\r\n\t            page_idx &= buddy_idx;\r\n\t            order ++;\r\n\t        }\r\n\t        struct Page page = idx2page(zone_num, page_idx);\r\n\t        page->property = order;\r\n\t        SetPageProperty(page);\r\n\t        nr_free(order) ++;\r\n\t        _--YOUR CODE 12--_(&free;_list(order), &(page->page_link));\r\n\t    }\r\n\t    //buddy_free_pages - call buddy_free_pages_sub to free n continuing page block\r\n\t    static void\r\n\t    buddy_free_pages(struct Page base, size_t n) {\r\n\t        assert(n > 0);\r\n\t        if (n == 1) {\r\n\t            buddy_free_pages_sub(base, 0);\r\n\t        }\r\n\t        else {\r\n\t            size_t order = 0, order_size = 1;\r\n\t            while (n >= order_size) {\r\n\t                assert(order <= MAX_ORDER);\r\n\t                if ((page2idx(base) & order_size) != 0) {\r\n\t                    buddy_free_pages_sub(base, order);\r\n\t                    base += order_size;\r\n\t                    n -= order_size;\r\n\t                }\r\n\t                order ++;\r\n\t                order_size <<= 1;\r\n\t            }\r\n\t            while (n != 0) {\r\n\t                while (n < order_size) {\r\n\t                    order --;\r\n\t                    order_size >>= 1;\r\n\t                }\r\n\t                buddy_free_pages_sub(base, order);\r\n\t                base += order_size;\r\n\t                n -= order_size;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    //buddy_nr_free_pages - get the nr: the number of free pages\r\n\t    static size_t\r\n\t    buddy_nr_free_pages(void) {\r\n\t        size_t ret = 0, order = 0;\r\n\t        for (; order <= MAX_ORDER; order ++) {\r\n\t            ret += nr_free(order)  (1 << order);\r\n\t        }\r\n\t        return ret;\r\n\t    }\r\n\t    //buddy_check - check the correctness of buddy system\r\n\t    static void\r\n\t    buddy_check(void) {\r\n\t    ……\r\n\t    }\r\n\t    //the buddy system pmm\r\n\t    const struct pmm_manager buddy_pmm_manager = {\r\n\t        .name = \"buddy_pmm_manager\",\r\n\t        .init = buddy_init,\r\n\t        .init_memmap = buddy_init_memmap,\r\n\t        .alloc_pages = buddy_alloc_pages,\r\n\t        .free_pages = buddy_free_pages,\r\n\t        .nr_free_pages = buddy_nr_free_pages,\r\n\t        .check = buddy_check,\r\n\t    };\r\n\t    ```\r\n    \r\n\r\n", "degree_of_difficulty": "1\r\n", "source": "网络\r\n", "answer": "1)", "type": "4\r\n", "options": "  \r\n"}