{"knowledge": "。\r\n", "question": "下面是ucore中用于按需分页处理过程的内核代码。请补全其中所缺的代码，以正确完成按需分页过程.\r\n    ```\r\n\t    kern/trap/trap.h\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    struct trapframe {\r\n\t        struct pushregs tf_regs;\r\n\t        uint16_t tf_es;\r\n\t        uint16_t tf_padding1;\r\n\t        uint16_t tf_ds;\r\n\t        uint16_t tf_padding2;\r\n\t        uint32_t tf_trapno;\r\n\t        / below here defined by x86 hardware /\r\n\t        uint32_t tf_err;\r\n\t        uintptr_t tf_eip;\r\n\t        uint16_t tf_cs;\r\n\t        uint16_t tf_padding3;\r\n\t        uint32_t tf_eflags;\r\n\t        // below here only when crossing rings, such as from user to kernel\r\n\t        uintptr_t tf_esp;\r\n\t        uint16_t tf_ss;\r\n\t        uint16_t tf_padding4;\r\n\t    } __attribute__((packed));\r\n\t    ...\r\n\t    ---------------------------------\r\n\t    kern/trap/trap.c\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    static int\r\n\t    pgfault_handler(struct trapframe tf) {\r\n\t        extern struct mm_struct check_mm_struct;\r\n\t    }\r\n\t    print_pgfault(tf);\r\n\t        if (check_mm_struct != NULL) {\r\n\t            return do_pgfault(check_mm_struct, tf->tf_err, rcr2());\r\n\t        }\r\n\t        panic(\"unhandled page fault.\r\n\t\");\r\n\t    }\r\n\t    static void\r\n\t    trap_dispatch(struct trapframe tf) {\r\n\t    char c;\r\n\t    int ret;\r\n\t    switch ( --YOUR CODE 1-- ) {\r\n\t         .YOUR..\r\n\t    case T_PGFLT:\r\n\t    if ( --YOUR CODE 2-- ) != 0) {\r\n\t    print_trapframe(trapf);\r\n\t    if (current == NULL) {\r\n\t    panic(\"handle pgfault failed. %e\r\n\t\",              ret);\r\n\t    }\r\n\t    else { ... }\r\n\t    }\r\n\t    break;\r\n\t      ...\r\n\t    }\r\n\t    void\r\n\t    trap(struct trapframe tf) {\r\n\t        // dispatch based on what type of trap occurred\r\n\t        trap_dispatch(tf);\r\n\t    }\r\n\t    ...\r\n\t    // do_pgfault - interrupt handler to process the page fault execption\r\n\t    int\r\n\t    do_pgfault(struct mm_struct mm, uint32_t error_code, uintptr_t addr) {\r\n\t        int ret = -E_INVAL;\r\n\t        struct vma_struct vma = find_vma(mm, addr);\r\n\t        if (vma == NULL || vma->vm_start > addr) {\r\n\t            goto failed;\r\n\t        }\r\n\t        switch (error_code & 3) {\r\n\t        default:\r\n\t                / default is 3: write, present /\r\n\t        case 2: / write, not present /\r\n\t            if (!(vma->vm_flags & VM_WRITE)) {\r\n\t                goto failed;\r\n\t            }\r\n\t            break;\r\n\t        case 1: / read, present /\r\n\t            goto failed;\r\n\t        case 0: / read, not present /\r\n\t            if (!(vma->vm_flags & (VM_READ | VM_EXEC))) {\r\n\t                goto failed;\r\n\t            }\r\n\t        }\r\n\t        uint32_t perm = PTE_U;\r\n\t        if (vma->vm_flags & VM_WRITE) {\r\n\t            perm |= PTE_W;\r\n\t        }\r\n\t        addr = ROUNDDOWN(addr, PGSIZE);\r\n\t        ret = -E_NO_MEM;\r\n\t        if (pgdir_alloc_page(mm->pgdir, addr, perm) == 0) {\r\n\t            goto failed;\r\n\t        }\r\n\t        ret = 0;\r\n\t    failed:\r\n\t        return ret;\r\n\t    }\r\n\t    ...\r\n\t    ---------------------------------\r\n\t    Pmm.h\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    //ppn is physical page number\r\n\t    static inline ppn_t\r\n\t    page2ppn(struct Page page) {\r\n\t        return --YOUR CODE 3--;\r\n\t    }\r\n\t    //pa is physical address\r\n\t    static inline uintptr_t\r\n\t    page2pa(struct Page page) {\r\n\t        return --YOUR CODE 4--;\r\n\t    }\r\n\t    ...\r\n\t    ---------------------------------\r\n\t    pmm.c\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    // virtual address of physicall page array\r\n\t    struct Page pages;\r\n\t    // amount of physical memory (in pages)\r\n\t    size_t npage = 0;\r\n\t    // virtual address of boot-time page directory\r\n\t    pde_t boot_pgdir = NULL;\r\n\t    ……\r\n\t    // pgdir_alloc_page - call alloc_page & page_insert functions to\r\n\t    //                  - allocate a page size memory & setup an addr map\r\n\t    //                  - pa<->la with linear address la and the PDT pgdir\r\n\t    struct Page \r\n\t    pgdir_alloc_page(pde_t pgdir, uintptr_t la, uint32_t perm) {\r\n\t        struct Page page = alloc_page();\r\n\t        if (page != NULL) {\r\n\t            if (page_insert(pgdir, page, la, perm) != 0) {\r\n\t                free_page(page);\r\n\t                return NULL;\r\n\t            }\r\n\t        }\r\n\t        return page;\r\n\t    }\r\n\t    ...\r\n\t    //page_insert - build the map of phy addr of an Page with the linear addr la\r\n\t    // paramemters:\r\n\t    //  pgdir: the kernel virtual base address of PDT\r\n\t    //  page:  the Page which need to map\r\n\t    //  la:    the linear address need to map\r\n\t    //  perm:  the permission of this Page which is setted in related pte\r\n\t    // return value: always 0\r\n\t    //note: PT is changed, so the TLB need to be invalidate\r\n\t    int\r\n\t    page_insert(pde_t pgdir, struct Page page, uintptr_t la, uint32_t perm) {\r\n\t        pte_t ptep = get_pte(pgdir, la, 1);\r\n\t        if (ptep == NULL) {\r\n\t            return -E_NO_MEM;\r\n\t        }\r\n\t        page_ref_inc(page);\r\n\t        if (ptep & PTE_P) {\r\n\t            struct Page p = pte2page(ptep);\r\n\t            if (p == page) {\r\n\t                page_ref_dec(page);\r\n\t            }\r\n\t            else {\r\n\t                page_remove_pte(pgdir, la, ptep);\r\n\t            }\r\n\t        }\r\n\t        ptep = --YOUR CODE 5--\r\n\t        tlb_invalidate(pgdir, la);\r\n\t        return 0;\r\n\t    }\r\n\t    ---------------------------------\r\n\t    ```\r\n    \r\n\r\n", "degree_of_difficulty": "1\r\n", "source": "网络\r\n", "answer": "Code1： tf->tf_trapno Code 2: ret = pgfault_handler(tf) Code 3: page - pages;", "type": "4\r\n", "options": "  \r\n"}