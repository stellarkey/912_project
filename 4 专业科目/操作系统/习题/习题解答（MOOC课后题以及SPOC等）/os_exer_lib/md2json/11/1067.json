{"knowledge": "进程状态与控制。\r\n", "question": "(16分)下面是ucore内核中与yield()系统调用实现相关源代码，可实现用户线程主动放弃CPU使用权的功能。\r\n1）试描述ucore中用户进程利用yield()进行主动让出CPU的工作过程；\r\n2）请补全其中所缺的代码，以正确完成从用户态函数yield()的功能。提示：每处需要补全的代码最少只需要一行，一共有11个空要填。当然，你可以在需要补全代码\r\n的地方写多行来表达需要实现的功能，也允许修改已给出的代码。\r\n    ```\r\n\t    libs-user-ucore/syscall.h\r\n\t    ================= libs-user-ucore/syscall.h ========================\r\n\t    #ifndef __USER_LIBS_SYSCALL_H__\r\n\t    #define __USER_LIBS_SYSCALL_H__\r\n\t    #include\r\n\t    ......\r\n\t    int sys_yield(void);\r\n\t    ......\r\n\t    #endif / !__USER_LIBS_SYSCALL_H__ /\r\n\t    =============================================================\r\n\t    libs-user-ucore/arch/i386/syscall.c\r\n\t    =============libs-user-ucore/arch/i386/syscall.c====================\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #define MAX_ARGS            5\r\n\t    uint32_t\r\n\t    syscall(int num, ...) {\r\n\t        va_list ap;\r\n\t        va_start(ap, num);\r\n\t        uint32_t a[MAX_ARGS];\r\n\t        int i;\r\n\t        for (i = 0; i < MAX_ARGS; i ++) {\r\n\t            a[i] = va_arg(ap, uint32_t);\r\n\t        }\r\n\t        va_end(ap);\r\n\t        uint32_t ret;\r\n\t        asm volatile (\r\n\t            \"int %1;\"\r\n\t            : \"=a\" (ret)\r\n\t            : \"i\" (T_SYSCALL),\r\n\t              \"a\" (num),\r\n\t              \"d\" (a[0]),\r\n\t              \"c\" (a[1]),\r\n\t              \"b\" (a[2]),\r\n\t              \"D\" (a[3]),\r\n\t              \"S\" (a[4])\r\n\t            : \"cc\", \"memory\");\r\n\t        return ret;\r\n\t    }\r\n\t    =============================================================\r\n\t    libs-user-ucore/syscall.c\r\n\t    ==================libs-user-ucore/syscall.c========================\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    extern uintptr_t syscall (int num, ...);\r\n\t    ......\r\n\t    int\r\n\t    sys_yield(void) {\r\n\t        return ……(1)……;\r\n\t    }\r\n\t    ......\r\n\t    =============================================================\r\n\t    kern-ucore/glue-ucore/libs/unistd.h\r\n\t    =============kern-ucore/glue-ucore/libs/unistd.h===================\r\n\t    #ifndef __LIBS_UNISTD_H__\r\n\t    #define __LIBS_UNISTD_H__\r\n\t    #define T_SYSCALL           0x80\r\n\t    / syscall number /\r\n\t    ......\r\n\t    #define SYS_yield           10\r\n\t    ......\r\n\t    #endif / !__LIBS_UNISTD_H__ /\r\n\t    =============================================================\r\n\t    kern-ucore/arch/i386/glue-ucore/trap.c\r\n\t    ============= kern-ucore/arch/i386/glue-ucore/trap.c ===============\r\n\t    ......\r\n\t    static void\r\n\t    trap_dispatch(struct trapframe tf) {\r\n\t        char c;\r\n\t        int ret;\r\n\t        switch (tf->tf_trapno) {\r\n\t        case T_DEBUG:\r\n\t        case T_BRKPT:\r\n\t            debug_monitor(tf);\r\n\t            break;\r\n\t        case T_PGFLT:\r\n\t            if ((ret = pgfault_handler(tf)) != 0) {\r\n\t                print_trapframe(tf);\r\n\t                if (pls_read(current) == NULL) {\r\n\t                    panic(\"handle pgfault failed. %e\r\n\t\", ret);\r\n\t                }\r\n\t                else {\r\n\t                    if (trap_in_kernel(tf)) {\r\n\t                        panic(\"handle pgfault failed in kernel mode. %e\r\n\t\", ret);\r\n\t                    }\r\n\t                    kprintf(\"killed by kernel.\r\n\t\");\r\n\t                    do_exit(-E_KILLED);\r\n\t                }\r\n\t            }\r\n\t            break;\r\n\t        case ……(2)……:\r\n\t            syscall();\r\n\t            break;\r\n\t        case IRQ_OFFSET + IRQ_TIMER:\r\n\t            ticks ++;\r\n\t            assert(pls_read(current) != NULL);\r\n\t            run_timer_list();\r\n\t            break;\r\n\t        case IRQ_OFFSET + IRQ_COM1:\r\n\t        case IRQ_OFFSET + IRQ_KBD:\r\n\t            if ((c = cons_getc()) == 13) {\r\n\t                debug_monitor(tf);\r\n\t            }\r\n\t            else {\r\n\t                extern void dev_stdin_write(char c);\r\n\t                dev_stdin_write(c);\r\n\t            }\r\n\t            break;\r\n\t        case IRQ_OFFSET + IRQ_IDE1:\r\n\t        case IRQ_OFFSET + IRQ_IDE2:\r\n\t            / do nothing /\r\n\t            break;\r\n\t        default:\r\n\t            print_trapframe(tf);\r\n\t            if (pls_read(current) != NULL) {\r\n\t                kprintf(\"unhandled trap.\r\n\t\");\r\n\t                do_exit(-E_KILLED);\r\n\t            }\r\n\t            panic(\"unexpected trap in kernel.\r\n\t\");\r\n\t        }\r\n\t    }\r\n\t    void\r\n\t    trap(struct trapframe tf) {\r\n\t        // used for previous projects\r\n\t        if (pls_read(current) == NULL) {\r\n\t            trap_dispatch(tf);\r\n\t        }\r\n\t        else {\r\n\t            // keep a trapframe chain in stack\r\n\t            struct trapframe otf = pls_read(current)->tf;\r\n\t            pls_read(current)->tf = tf;\r\n\t            bool in_kernel = trap_in_kernel(tf);\r\n\t            trap_dispatch(tf);\r\n\t            pls_read(current)->tf = otf;\r\n\t            if (!in_kernel) {\r\n\t                may_killed();\r\n\t                if (pls_read(current)->need_resched) {\r\n\t                    ……(3)……;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    =============================================================\r\n\t    kern-ucore/schedule/sched.c\r\n\t    =============kern-ucore/schedule/sched.c=========================\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #define current (pls_read(current))\r\n\t    #define idleproc (pls_read(idleproc))\r\n\t    ......\r\n\t    #include\r\n\t    #define MT_SUPPORT\r\n\t    void\r\n\t    schedule(void) {\r\n\t        bool intr_flag;\r\n\t        struct proc_struct next;\r\n\t    #ifndef MT_SUPPORT\r\n\t        list_entry_t head;\r\n\t        int lapic_id = pls_read(lapic_id);\r\n\t    #endif\r\n\t        local_intr_save(intr_flag);\r\n\t        int lcpu_count = pls_read(lcpu_count);\r\n\t        {\r\n\t            current->need_resched = ……(4)……;\r\n\t    #ifndef MT_SUPPORT\r\n\t            if (current->mm)\r\n\t            {\r\n\t                assert(current->mm->lapic == lapic_id);\r\n\t                current->mm->lapic = -1;\r\n\t            }\r\n\t    #endif\r\n\t            if (current->state == PROC_RUNNABLE && current->pid >= lcpu_count) {\r\n\t                sched_class_enqueue(current);\r\n\t            }\r\n\t    #ifndef MT_SUPPORT\r\n\t            list_init(&head;);\r\n\t            while (1)\r\n\t            {\r\n\t                next = ……(5)……;\r\n\t                if (next != NULL) sched_class_dequeue(next);\r\n\t                if (next && next->mm && next->mm->lapic != -1)\r\n\t                {\r\n\t                    list_add(&head;, &(next->run_link));\r\n\t                }\r\n\t                else\r\n\t                {\r\n\t                    list_entry_t cur;\r\n\t                    while ((cur = list_next(&head;)) != &head;)\r\n\t                    {\r\n\t                        list_del_init(cur);\r\n\t                        sched_class_enqueue(le2proc(cur, run_link));\r\n\t                    }\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t    #else\r\n\t            next = ……(6)……;\r\n\t            if (next != NULL)\r\n\t                sched_class_dequeue(next);\r\n\t    #endif  / !MT_SUPPORT /\r\n\t            if (next == NULL) {\r\n\t                next = ……(7)……;\r\n\t            }\r\n\t            next->runs ++;\r\n\t            / Collect information here/\r\n\t            if (sched_collect_info) {\r\n\t                int lcpu_count = pls_read(lcpu_count);\r\n\t                int lcpu_idx = pls_read(lcpu_idx);\r\n\t                int loc = sched_info_head[lcpu_idx];\r\n\t                int prev = sched_info_pid[loclcpu_count + lcpu_idx];\r\n\t                if (next->pid == prev)\r\n\t                    sched_info_times[loclcpu_count + lcpu_idx] ++;\r\n\t                else {\r\n\t                    sched_info_head[lcpu_idx] ++;\r\n\t                    if (sched_info_head[lcpu_idx] >= PGSIZE / sizeof(uint16_t) / lcpu_count)\r\n\t                        sched_info_head[lcpu_idx] = 0;\r\n\t                    loc = sched_info_head[lcpu_idx];\r\n\t                    uint16_t prev_pid = sched_info_pid[loclcpu_count + lcpu_idx];\r\n\t                    uint16_t prev_times = sched_info_times[loclcpu_count + lcpu_idx];\r\n\t                    if (prev_times > 0 && prev_pid >= lcpu_count + 2)\r\n\t                        sched_slices[lcpu_idx][prev_pid % SLICEPOOL_SIZE] += prev_times;\r\n\t                    sched_info_pid[loclcpu_count + lcpu_idx] = next->pid;\r\n\t                    sched_info_times[loclcpu_count + lcpu_idx] = 1;\r\n\t                }\r\n\t            }\r\n\t    #ifndef MT_SUPPORT\r\n\t            assert(!next->mm || next->mm->lapic == -1);\r\n\t            if (next->mm)\r\n\t                next->mm->lapic = lapic_id;\r\n\t    #endif\r\n\t            if (next != current) {\r\n\t                ……(8)……;\r\n\t            }\r\n\t        }\r\n\t        local_intr_restore(intr_flag);\r\n\t    }\r\n\t    void\r\n\t    add_timer(timer_t timer) {\r\n\t        bool intr_flag;\r\n\t        local_intr_save(intr_flag);\r\n\t        {\r\n\t            assert(timer->expires > 0 && timer->proc != NULL);\r\n\t            assert(list_empty(&(timer->timer_link)));\r\n\t            list_entry_t le = list_next(&timer;_list);\r\n\t            while (le != &timer;_list) {\r\n\t                timer_t next = le2timer(le, timer_link);\r\n\t                if (timer->expires < next->expires) {\r\n\t                    next->expires -= timer->expires;\r\n\t                    break;\r\n\t                }\r\n\t                timer->expires -= next->expires;\r\n\t                le = list_next(le);\r\n\t            }\r\n\t            list_add_before(le, &(timer->timer_link));\r\n\t        }\r\n\t        local_intr_restore(intr_flag);\r\n\t    }\r\n\t    ......\r\n\t    =============================================================\r\n\t    kern-ucore/process/proc.c\r\n\t    ================kern-ucore/process/proc.c========================\r\n\t    ......\r\n\t    // proc_run - make process \"proc\" running on cpu\r\n\t    // NOTE: before call switch_to, should load  base addr of \"proc\"'s new PDT\r\n\t    void\r\n\t    proc_run(struct proc_struct proc) {\r\n\t        if (proc != current) {\r\n\t            bool intr_flag;\r\n\t            struct proc_struct prev = current, next = proc;\r\n\t            // kprintf(\"(%d) => %d\r\n\t\", lapic_id, next->pid);\r\n\t            local_intr_save(intr_flag);\r\n\t            {\r\n\t                pls_write(current, proc);\r\n\t                load_rsp0(next->kstack + KSTACKSIZE);\r\n\t                mp_set_mm_pagetable(next->mm);\r\n\t                ……(9)……;\r\n\t            }\r\n\t            local_intr_restore(intr_flag);\r\n\t        }\r\n\t    }\r\n\t    ......\r\n\t    // do_yield - ask the scheduler to reschedule\r\n\t    int\r\n\t    do_yield(void) {\r\n\t        current->need_resched = ……(10)……;\r\n\t        return 0;\r\n\t    }\r\n\t    ......\r\n\t    =============================================================\r\n\t    kern-ucore/arch/i386/syscall/syscall.c\r\n\t    =============kern-ucore/arch/i386/syscall/syscall.c=================\r\n\t    ......\r\n\t    static uint32_t\r\n\t    sys_yield(uint32_t arg[]) {\r\n\t        return ……(11)……;\r\n\t    }\r\n\t    ......\r\n\t    static uint32_t (syscalls[])(uint32_t arg[]) = {\r\n\t    ......\r\n\t        [SYS_yield]             sys_yield,\r\n\t    ......\r\n\t    };\r\n\t    #define NUM_SYSCALLS        ((sizeof(syscalls)) / (sizeof(syscalls[0])))\r\n\t    void\r\n\t    syscall(void) {\r\n\t        struct trapframe tf = pls_read(current)->tf;\r\n\t        uint32_t arg[5];\r\n\t        int num = tf->tf_regs.reg_eax;\r\n\t        if (num >= 0 && num < NUM_SYSCALLS) {\r\n\t            if (syscalls[num] != NULL) {\r\n\t                arg[0] = tf->tf_regs.reg_edx;\r\n\t                arg[1] = tf->tf_regs.reg_ecx;\r\n\t                arg[2] = tf->tf_regs.reg_ebx;\r\n\t                arg[3] = tf->tf_regs.reg_edi;\r\n\t                arg[4] = tf->tf_regs.reg_esi;\r\n\t                tf->tf_regs.reg_eax = syscalls[num](arg);\r\n\t                return ;\r\n\t            }\r\n\t        }\r\n\t        print_trapframe(tf);\r\n\t        panic(\"undefined syscall %d, pid = %d, name = %s.\r\n\t\",\r\n\t                num, pls_read(current)->pid, pls_read(current)->name);\r\n\t    }\r\n\t    =============================================================\r\n\t    ```\r\n    \r\n\r\n", "degree_of_difficulty": "1\r\n", "source": "网络\r\n", "answer": "第一问5分；第二问11分；", "type": "4\r\n", "options": "  \r\n"}