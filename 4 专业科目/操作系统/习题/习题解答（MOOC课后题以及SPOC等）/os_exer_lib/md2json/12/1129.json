{"knowledge": "启动和中断处理实验。\r\n", "question": "管程：实现代码填空、读者优先的应用代码完成；\r\n第四题： 一、 （22分）管程是操作系统提供的一种进程同步机制，利用管程可解决进程间通信时遇到的同步互斥问题。读者-写者问题（Reader-writer\r\nproblem）是一个经典的同步问题。写者优先的读者-写者问题是指，假定有多个并发的读进程和写进程都要访问一个共享的数据结构，要求：(1)读写互斥；(2)写\r\n写互斥；(3)允许多个读进程同时访问；(4)只要有写进程提出申请，其后提出申请的读进程就必须等待该写进程完成访问\r\n。下面是ucore中管程机制和写者优先的读者-写者问题的实现代码。请尝试补全其中所缺的代码，以正确实现管程机制和读者-\r\n写者间的读写操作协调。提示：文件“cdt_wf.c”中的补全代码可能需要在一处加多行代码，其他需要补全的代码只需要一行，一共有11个空要填。\r\n    ```\r\n\t    condition.h\r\n\t    -----------------------------------------------\r\n\t    …\r\n\t    typedef struct {\r\n\t          int numWaiting;\r\n\t      int valid;\r\n\t      wait_queue_t wait_queue;\r\n\t    } condition_t;\r\n\t    #define cdtid2cdt(cdt_id)                       \\\r\n\t        ((condition_t )((uintptr_t)(cdt_id) + KERNBASE))\r\n\t    #define cdt2cdtid(cdt)                          \\\r\n\t        ((cdt_t)((uintptr_t)(cdt) - KERNBASE))\r\n\t    void\r\n\t    condition_value_init(condition_t cdt) {\r\n\t      ...(1)...\r\n\t      cdt->valid=1;\r\n\t            wait_queue_init(&(cdt->wait_queue));\r\n\t    }\r\n\t    int\r\n\t    condition_init(){\r\n\t      condition_t cdt;\r\n\t      if ((cdt = kmalloc(sizeof(condition_t))) != NULL) {\r\n\t        condition_value_init( cdt );\r\n\t          }\r\n\t        if (cdt != NULL) {\r\n\t              return cdt2cdtid(cdt);\r\n\t          }\r\n\t      return -E_INVAL;\r\n\t    }\r\n\t    int\r\n\t    condition_free(cdt_t cdt_id) {\r\n\t          condition_t cdt = cdtid2cdt(cdt_id);\r\n\t          int ret = -E_INVAL;\r\n\t          if (cdt != NULL) {\r\n\t              bool intr_flag;\r\n\t              local_intr_save(intr_flag);\r\n\t              {\r\n\t                    cdt->valid = 0, ret = 0;\r\n\t                    wakeup_queue(&(cdt->wait_queue), WT_INTERRUPTED, 1);\r\n\t              kfree(cdt);\r\n\t              }\r\n\t              local_intr_restore(intr_flag);\r\n\t          }\r\n\t      return ret;\r\n\t    }\r\n\t    int\r\n\t    condition_wait(cdt_t cdt_id, klock_t kl_id){\r\n\t      condition_t cdt = cdtid2cdt(cdt_id);\r\n\t          bool intr_flag;\r\n\t          local_intr_save(intr_flag);\r\n\t      ...(2)...\r\n\t          wait_t __wait, wait = &__wait;\r\n\t          ...(3)...\r\n\t          local_intr_restore(intr_flag);\r\n\t          sys_unlock(kl_id);\r\n\t          schedule();\r\n\t          sys_lock(kl_id);\r\n\t          //local_intr_save(intr_flag);\r\n\t          //wait_current_del(&(cdt->wait_queue), wait);\r\n\t          //local_intr_restore(intr_flag);\r\n\t          if (wait->wakeup_flags != WT_UCONDITION) {\r\n\t              return wait->wakeup_flags;\r\n\t          }\r\n\t          return 0;\r\n\t    }\r\n\t    int\r\n\t    condition_signal(cdt_t cdt_id){\r\n\t          condition_t cdt = cdtid2cdt(cdt_id);\r\n\t          if (cdt == NULL) {\r\n\t        return -E_INVAL;\r\n\t      }\r\n\t      bool intr_flag;\r\n\t          local_intr_save(intr_flag);\r\n\t      if (cdt->numWaiting > 0) {\r\n\t              wait_t wait;\r\n\t              if ((wait = wait_queue_first(&(cdt->wait_queue))) != NULL) {\r\n\t                    assert(wait->proc->wait_state == WT_UCONDITION);\r\n\t                    ...(4)...\r\n\t            }\r\n\t        ...(5)...\r\n\t          }\r\n\t          local_intr_restore(intr_flag);\r\n\t      return 0;\r\n\t    }\r\n\t    …\r\n\t    -----------------------------------------------\r\n\t    ulib.c\r\n\t    -----------------------------------------------\r\n\t    …\r\n\t    cdt_t\r\n\t    cdt_init(){\r\n\t      return sys_cdt_init();\r\n\t    }\r\n\t    int\r\n\t    cdt_signal(cdt_t cdt_id){\r\n\t      return sys_cdt_signal(cdt_id);\r\n\t    }\r\n\t    int\r\n\t    cdt_wait(cdt_t cdt_id ,klock_t klock_id){\r\n\t      return sys_cdt_wait(cdt_id ,klock_id);\r\n\t    }\r\n\t    int\r\n\t    cdt_free(cdt_t cdt_id){\r\n\t      return sys_cdt_free(cdt_id);\r\n\t    }\r\n\t    klock_t\r\n\t    klock_init(){\r\n\t      return sys_klock_init();\r\n\t    }\r\n\t    int\r\n\t    klock_aquire(klock_t klock_id){\r\n\t      return sys_klock_aquire(klock_id);\r\n\t    }\r\n\t    int\r\n\t    klock_release(klock_t klock_id){\r\n\t      return sys_klock_release(klock_id);\r\n\t    }\r\n\t    int\r\n\t    klock_free(klock_t klock_id){\r\n\t      return sys_klock_free(klock_id);\r\n\t    }\r\n\t    …\r\n\t    -----------------------------------------------\r\n\t    cdt_wf.c\r\n\t    -----------------------------------------------\r\n\t    …\r\n\t    int active_reader ;    // # count of active readers\r\n\t    int active_writer ;  // # count of active writers\r\n\t    int waiting_reader ;   // # count of waiting readers\r\n\t    int waiting_writer ;   // # count of waiting writers\r\n\t    cdt_t cdt_okToRead;\r\n\t    cdt_t cdt_okToWrite;\r\n\t    klock_t lock;\r\n\t    void\r\n\t    failed(void) {\r\n\t        cprintf(\"FAIL: T.T\r\n\t\");\r\n\t        exit(-1);\r\n\t    }\r\n\t    void\r\n\t    init(void) {\r\n\t        if ((cdt_okToRead = cdt_init()) < 0 || (cdt_okToWrite = cdt_init()) < 0) {\r\n\t            failed();\r\n\t        }\r\n\t        if ((lock = klock_init()) < 0) {\r\n\t            failed();\r\n\t        }\r\n\t        if ((active_reader = shmem_malloc(sizeof(int))) == NULL || (active_writer = shmem_malloc(sizeof(int))) == NULL\r\n\t      || (waiting_reader = shmem_malloc(sizeof(int))) == NULL || (waiting_writer = shmem_malloc(sizeof(int))) == NULL) {\r\n\t            failed();\r\n\t        }\r\n\t        active_reader = active_writer = waiting_reader = waiting_writer = 0;\r\n\t    }\r\n\t    void\r\n\t    check_init_value(void) {\r\n\t        if (cdt_okToRead < 0 || cdt_okToWrite < 0 ) {\r\n\t      failed();\r\n\t        }\r\n\t        if (lock < 0 ) {\r\n\t            failed();\r\n\t        }\r\n\t        if (active_reader != 0 || active_writer != 0 || waiting_reader != 0 || waiting_writer != 0) {\r\n\t            failed();\r\n\t        }\r\n\t    }\r\n\t    void\r\n\t    free_wf(void){\r\n\t      if (  cdt_free(cdt_okToRead) < 0 ||  cdt_free(cdt_okToWrite) < 0 ){\r\n\t        scprintf(\" conditon free failed! \r\n\t\");\r\n\t        exit(-1);\r\n\t      }\r\n\t      if (  klock_free(lock) < 0 ){\r\n\t        scprintf(\" kernal lock free failed! \r\n\t\");\r\n\t        exit(-1);\r\n\t      }\r\n\t    }\r\n\t    void\r\n\t    start_read(void) {\r\n\t      klock_aquire(lock);\r\n\t            ...(6)...\r\n\t            klock_release(lock);\r\n\t    }\r\n\t    void\r\n\t    done_read(void) {\r\n\t      klock_aquire(lock);\r\n\t            ...(7)...\r\n\t      klock_release(lock);\r\n\t    }\r\n\t    void\r\n\t    start_write(void) {\r\n\t      klock_aquire(lock);\r\n\t            ...(8)...\r\n\t      klock_release(lock);\r\n\t    }\r\n\t    void\r\n\t    done_write(void) {\r\n\t      klock_aquire(lock);\r\n\t            ...(9)...\r\n\t            if ((waiting_writer) > 0) {\r\n\t                 ...(10)...\r\n\t            }\r\n\t            else if ((waiting_reader) > 0) {\r\n\t        int wakecount=0;\r\n\t        while(...(11)...){\r\n\t          cdt_signal(cdt_okToRead);\r\n\t          wakecount++;\r\n\t        }\r\n\t            }\r\n\t      klock_release(lock);\r\n\t    }\r\n\t    void\r\n\t    writer(int id, int time) {\r\n\t      scprintf(\"writer %d: (pid:%d) arrive \r\n\t\", id, getpid());\r\n\t            start_write();\r\n\t            scprintf(\"    writer_wf %d: (pid:%d) start %d\r\n\t\", id, getpid(), time);\r\n\t          sleep(time);\r\n\t          scprintf(\"    writer_wf %d: (pid:%d) end %d\r\n\t\", id, getpid(), time);\r\n\t            done_write();\r\n\t    }\r\n\t    void\r\n\t    reader(int id, int time) {\r\n\t          scprintf(\"reader %d: (pid:%d) arrive\r\n\t\", id, getpid());\r\n\t        start_read();\r\n\t          scprintf(\"    reader_wf %d: (pid:%d) start %d\r\n\t\", id, getpid(), time);\r\n\t          sleep(time);\r\n\t          scprintf(\"    reader_wf %d: (pid:%d) end %d\r\n\t\", id, getpid(), time);\r\n\t      done_read();\r\n\t    }\r\n\t    void\r\n\t    read_test_wf(void) {\r\n\t    …\r\n\t    }\r\n\t    void\r\n\t    write_test_wf(void) {\r\n\t    …\r\n\t    }\r\n\t    void\r\n\t    read_write_test_wf(void) {\r\n\t    …\r\n\t    }\r\n\t    int\r\n\t    main(void) {\r\n\t        init();\r\n\t        read_test_wf();\r\n\t        write_test_wf();\r\n\t        read_write_test_wf();\r\n\t        free_wf();\r\n\t        cprintf(\"condition reader_writer_wf_test pass..\r\n\t\");\r\n\t        return 0;\r\n\t    }\r\n\t    -----------------------------------------------\r\n\t    wait.c\r\n\t    -----------------------------------------------\r\n\t    …\r\n\t    void\r\n\t    wait_init(wait_t wait, struct proc_struct proc) {\r\n\t        wait->proc = proc;\r\n\t        wait->wakeup_flags = WT_INTERRUPTED;\r\n\t        list_init(&(wait->wait_link));\r\n\t    }\r\n\t    void\r\n\t    wait_queue_init(wait_queue_t queue) {\r\n\t        list_init(&(queue->wait_head));\r\n\t    }\r\n\t    void\r\n\t    wait_queue_add(wait_queue_t queue, wait_t wait) {\r\n\t        assert(list_empty(&(wait->wait_link)) && wait->proc != NULL);\r\n\t        wait->wait_queue = queue;\r\n\t        list_add_before(&(queue->wait_head), &(wait->wait_link));\r\n\t    }\r\n\t    void\r\n\t    wait_queue_del(wait_queue_t queue, wait_t wait) {\r\n\t        assert(!list_empty(&(wait->wait_link)) && wait->wait_queue == queue);\r\n\t        list_del_init(&(wait->wait_link));\r\n\t    }\r\n\t    wait_t \r\n\t    wait_queue_next(wait_queue_t queue, wait_t wait) {\r\n\t        assert(!list_empty(&(wait->wait_link)) && wait->wait_queue == queue);\r\n\t        list_entry_t le = list_next(&(wait->wait_link));\r\n\t        if (le != &(queue->wait_head)) {\r\n\t            return le2wait(le, wait_link);\r\n\t        }\r\n\t        return NULL;\r\n\t    }\r\n\t    wait_t \r\n\t    wait_queue_prev(wait_queue_t queue, wait_t wait) {\r\n\t        assert(!list_empty(&(wait->wait_link)) && wait->wait_queue == queue);\r\n\t        list_entry_t le = list_prev(&(wait->wait_link));\r\n\t        if (le != &(queue->wait_head)) {\r\n\t            return le2wait(le, wait_link);\r\n\t        }\r\n\t        return NULL;\r\n\t    }\r\n\t    wait_t \r\n\t    wait_queue_first(wait_queue_t queue) {\r\n\t        list_entry_t le = list_next(&(queue->wait_head));\r\n\t        if (le != &(queue->wait_head)) {\r\n\t            return le2wait(le, wait_link);\r\n\t        }\r\n\t        return NULL;\r\n\t    }\r\n\t    wait_t \r\n\t    wait_queue_last(wait_queue_t queue) {\r\n\t        list_entry_t le = list_prev(&(queue->wait_head));\r\n\t        if (le != &(queue->wait_head)) {\r\n\t            return le2wait(le, wait_link);\r\n\t        }\r\n\t        return NULL;\r\n\t    }\r\n\t    bool\r\n\t    wait_queue_empty(wait_queue_t queue) {\r\n\t        return list_empty(&(queue->wait_head));\r\n\t    }\r\n\t    bool\r\n\t    wait_in_queue(wait_t wait) {\r\n\t        return !list_empty(&(wait->wait_link));\r\n\t    }\r\n\t    void\r\n\t    wakeup_wait(wait_queue_t queue, wait_t wait, uint32_t wakeup_flags, bool del) {\r\n\t        if (del) {\r\n\t            wait_queue_del(queue, wait);\r\n\t        }\r\n\t        wait->wakeup_flags = wakeup_flags;\r\n\t        wakeup_proc(wait->proc);\r\n\t    }\r\n\t    void\r\n\t    wakeup_first(wait_queue_t queue, uint32_t wakeup_flags, bool del) {\r\n\t        wait_t wait;\r\n\t        if ((wait = wait_queue_first(queue)) != NULL) {\r\n\t            wakeup_wait(queue, wait, wakeup_flags, del);\r\n\t        }\r\n\t    }\r\n\t    void\r\n\t    wakeup_queue(wait_queue_t queue, uint32_t wakeup_flags, bool del) {\r\n\t        wait_t wait;\r\n\t        if ((wait = wait_queue_first(queue)) != NULL) {\r\n\t            if (del) {\r\n\t                do {\r\n\t                    wakeup_wait(queue, wait, wakeup_flags, 1);\r\n\t                } while ((wait = wait_queue_first(queue)) != NULL);\r\n\t            }\r\n\t            else {\r\n\t                do {\r\n\t                    wakeup_wait(queue, wait, wakeup_flags, 0);\r\n\t                } while ((wait = wait_queue_next(queue, wait)) != NULL);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    void\r\n\t    wait_current_set(wait_queue_t queue, wait_t wait, uint32_t wait_state) {\r\n\t        assert(current != NULL);\r\n\t        wait_init(wait, current);\r\n\t        current->state = PROC_SLEEPING;\r\n\t        current->wait_state = wait_state;\r\n\t        wait_queue_add(queue, wait);\r\n\t    }\r\n\t    -----------------------------------------------\r\n\t    proc.h\r\n\t    -----------------------------------------------\r\n\t    …\r\n\t    //the wait state\r\n\t    #define WT_CHILD        (0x00000001 | WT_INTERRUPTED)  // wait child process\r\n\t    #define WT_TIMER        (0x00000002 | WT_INTERRUPTED)  // wait timer\r\n\t    #define WT_KSWAPD       0x00000003                    // wait kswapd to free page\r\n\t    #define WT_KSEM         0x00000100                    // wait kernel semaphore\r\n\t    #define WT_USEM         (0x00000101 | WT_INTERRUPTED)  // wait user semaphore\r\n\t    #define WT_EVENT_SEND  (0x00000110 | WT_INTERRUPTED)  // wait the sending event\r\n\t    #define WT_EVENT_RECV  (0x00000111 | WT_INTERRUPTED)  // wait the recving event\r\n\t    #define WT_MBOX_SEND   (0x00000120 | WT_INTERRUPTED)  // wait the sending mbox\r\n\t    #define WT_MBOX_RECV   (0x00000121 | WT_INTERRUPTED)  // wait the recving mbox\r\n\t    #define WT_UCONDITION  (0x00000130 | WT_INTERRUPTED)  // wait user condition    --liuruilin\r\n\t    #define WT_INTERRUPTED 0x80000000 // the wait state could be interrupted\r\n\t    …\r\n\t    -----------------------------------------------\r\n\t    ```\r\n    \r\n\r\n", "degree_of_difficulty": "1\r\n", "source": "网络\r\n", "answer": "解释", "type": "4\r\n", "options": "  \r\n"}