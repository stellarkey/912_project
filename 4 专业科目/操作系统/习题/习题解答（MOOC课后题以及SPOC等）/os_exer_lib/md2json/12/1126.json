{"knowledge": "启动和中断处理实验。\r\n", "question": "系统调用访问过程\r\n第一题： 一、（2362H2分）下面是与read()系统调用实现相关源代码。请补全其中所缺的代码，以正确完成从用户态函数read()到内核态函数sysfil\r\ne_read()的参数传递和返回过程。提示：每处需要补全的代码只需要一行，一共有10个空要填。\r\n    ```\r\n\t    user/libs/file.c\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    int\r\n\t    read(int fd, void base, size_t len) {\r\n\t        ...(1)...\r\n\t    }\r\n\t    ...\r\n\t    ---------------------------------\r\n\t    user/libs/syscall.c\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    #define MAX_ARGS\r\n\t    static inline int\r\n\t    syscall(int num, ...) {\r\n\t              int ret;\r\n\t              va_list ap;\r\n\t             va_start(ap, num);\r\n\t             uint32_t a[MAX_ARGS];\r\n\t             int i;\r\n\t             for (i = 0; i < MAX_ARGS; i ++) {\r\n\t                       a[i] = va_arg(ap, uint32_t);\r\n\t             }\r\n\t             va_end(ap);\r\n\t             asm volatile (\r\n\t                                \"int %1;\"\r\n\t                                : \"=a\" (ret)\r\n\t                                : \"i\" (T_SYSCALL),\r\n\t                                  \"a\" (num),\r\n\t                                  \"d\" (a[0]),\r\n\t                                  \"c\" (a[1]),\r\n\t                                  \"b\" (a[2]),\r\n\t                                  \"D\" (a[3]),\r\n\t                                  \"S\" (a[4])\r\n\t                                : \"cc\", \"memory\");\r\n\t             return ret;\r\n\t    }\r\n\t    ...\r\n\t    int\r\n\t    sys_read(int fd, void base, size_t len) {\r\n\t             ...(2)...\r\n\t    }\r\n\t    ...\r\n\t    ---------------------------------\r\n\t    libs/stdarg.h\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    typedef char  va_list;\r\n\t    #define __va_size(type)                                                              \\\r\n\t             ((sizeof(type) + (sizeof(long) - 1)) / sizeof(long)  sizeof(long))\r\n\t    #define va_start(ap, last)                                                    \\\r\n\t             ((ap) = (va_list)&(last) + __va_size(last))\r\n\t    #define va_arg(ap, type)                                                    \\\r\n\t             ((type )((ap) += __va_size(type), (ap) - __va_size(type)))\r\n\t    #define va_end(ap)             ((void)0)\r\n\t    ...\r\n\t    ---------------------------------\r\n\t    libs/unistd.h\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    #define T_SYSCALL                           0x80\r\n\t    / syscall number /\r\n\t    ...\r\n\t    #define SYS_read                       102\r\n\t    #define SYS_write                      103\r\n\t    ...\r\n\t    ---------------------------------\r\n\t    kern/syscall/syscall.c\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    struct trapframe {\r\n\t             struct pushregs tf_regs;\r\n\t             uint16_t tf_es;\r\n\t             uint16_t tf_padding1;\r\n\t             uint16_t tf_ds;\r\n\t             uint16_t tf_padding2;\r\n\t             uint32_t tf_trapno;\r\n\t             / below here defined by x86 hardware /\r\n\t             uint32_t tf_err;\r\n\t             uintptr_t tf_eip;\r\n\t             uint16_t tf_cs;\r\n\t             uint16_t tf_padding3;\r\n\t             uint32_t tf_eflags;\r\n\t             / below here only when crossing rings, such as from user to kernel /\r\n\t             uintptr_t tf_esp;\r\n\t             uint16_t tf_ss;\r\n\t             uint16_t tf_padding4;\r\n\t    };\r\n\t    ...\r\n\t    ---------------------------------\r\n\t    kern/trap/trap.c\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    static void\r\n\t    trap_dispatch(struct trapframe tf) {\r\n\t             char c;\r\n\t             int ret;\r\n\t             switch (...(3)...) {\r\n\t             case T_DEBUG:\r\n\t             case T_BRKPT:\r\n\t                       debug_monitor(tf);\r\n\t                       break;\r\n\t             case T_PGFLT:\r\n\t                       if ((ret = pgfault_handler(tf)) != 0) {\r\n\t                                print_trapframe(tf);\r\n\t                                if (current == NULL) {\r\n\t                                         panic(\"handle pgfault failed. %e\r\n\t\", ret);\r\n\t                                }\r\n\t                                else {\r\n\t                                         if (trap_in_kernel(tf)) {\r\n\t                                                   panic(\"handle pgfault failed in kernel mode. %e\r\n\t\", ret);\r\n\t                                         }\r\n\t                                         cprintf(\"killed by kernel.\r\n\t\");\r\n\t                                         do_exit(-E_KILLED);\r\n\t                                }\r\n\t                       }\r\n\t                       break;\r\n\t             case T_SYSCALL:\r\n\t                       ...(4)...\r\n\t                       break;\r\n\t             case IRQ_OFFSET + IRQ_TIMER:\r\n\t                       ticks ++;\r\n\t                       assert(current != NULL);\r\n\t                       run_timer_list();\r\n\t                       break;\r\n\t             case IRQ_OFFSET + IRQ_COM1:\r\n\t             case IRQ_OFFSET + IRQ_KBD:\r\n\t                      if ((c = cons_getc()) == 13) {\r\n\t                                debug_monitor(tf);\r\n\t                       }\r\n\t                       else {\r\n\t                                extern void dev_stdin_write(char c);\r\n\t                                dev_stdin_write(c);\r\n\t                       }\r\n\t                       break;\r\n\t             case IRQ_OFFSET + IRQ_IDE1:\r\n\t             case IRQ_OFFSET + IRQ_IDE2:\r\n\t                       / do nothing /\r\n\t                       break;\r\n\t             default:\r\n\t                       print_trapframe(tf);\r\n\t                       if (current != NULL) {\r\n\t                                cprintf(\"unhandled trap.\r\n\t\");\r\n\t                                do_exit(-E_KILLED);\r\n\t                       }\r\n\t                       panic(\"unexpected trap in kernel.\r\n\t\");\r\n\t             }\r\n\t    }\r\n\t    void\r\n\t    trap(struct trapframe tf) {\r\n\t             // used for previous projects\r\n\t             if (current == NULL) {\r\n\t                       trap_dispatch(tf);\r\n\t             }\r\n\t             else {\r\n\t                       // keep a trapframe chain in stack\r\n\t                       struct trapframe otf = current->tf;\r\n\t                       current->tf = tf;\r\n\t                       bool in_kernel = trap_in_kernel(tf);\r\n\t                       ...(5)...\r\n\t                       current->tf = otf;\r\n\t                       if (!in_kernel) {\r\n\t                                if (current->flags & PF_EXITING) {\r\n\t                                         do_exit(-E_KILLED);\r\n\t                                }\r\n\t                                if (current->need_resched) {\r\n\t                                         schedule();\r\n\t                                }\r\n\t                       }\r\n\t             }\r\n\t    }\r\n\t    ...\r\n\t    ---------------------------------\r\n\t    kern/syscall/syscall.c\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    static int\r\n\t    sys_read(uint32_t arg[]) {\r\n\t             int fd = (int)arg[0];\r\n\t             size_t len = (size_t)...(6)...;\r\n\t             void base = (void )...(7)...;\r\n\t             ...(8a)...\r\n\t    }\r\n\t    ...\r\n\t    static int (syscalls[])(uint32_t arg[]) = {\r\n\t    ...\r\n\t             [SYS_read]                               sys_read,\r\n\t             [SYS_write]                              sys_write,\r\n\t    ...\r\n\t             [SYS_mkfifo]                            sys_mkfifo,\r\n\t    };\r\n\t    #define NUM_SYSCALLS          ((sizeof(syscalls)) / (sizeof(syscalls[0])))\r\n\t    void\r\n\t    syscall(void) {\r\n\t             struct trapframe tf = current->tf;\r\n\t             uint32_t arg[5];\r\n\t             int num = tf->...(8b)...;\r\n\t             if (num >= 0 && num < NUM_SYSCALLS) {\r\n\t                       if (syscalls[num] != NULL) {\r\n\t                                arg[0] = tf->tf_regs.reg_edx;\r\n\t                                arg[1] = tf->tf_regs.reg_ecx;\r\n\t                                arg[2] = tf->tf_regs.reg_ebx;\r\n\t                                arg[3] = tf->tf_regs.reg_edi;\r\n\t                                arg[4] = tf->tf_regs.reg_esi;\r\n\t                                tf->tf_regs.reg_eax = ...(9)...;\r\n\t                                return ;\r\n\t                       }\r\n\t             }\r\n\t             print_trapframe(tf);\r\n\t             panic(\"undefined syscall %d, pid = %d, name = %s.\r\n\t\",\r\n\t                                num, current->pid, current->name);\r\n\t    }\r\n\t    ...\r\n\t    ---------------------------------\r\n\t    kern/fs/sysfile.c\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    int\r\n\t    sysfile_read(int fd, void base, size_t len) {\r\n\t             struct mm_struct mm = current->mm;\r\n\t             if (len == 0) {\r\n\t                       return 0;\r\n\t             }\r\n\t             if (!file_testfd(fd, 1, 0)) {\r\n\t                       return -E_INVAL;\r\n\t             }\r\n\t             void buffer;\r\n\t             if ((buffer = kmalloc(IOBUF_SIZE)) == NULL) {\r\n\t                       return -E_NO_MEM;\r\n\t             }\r\n\t             int ret = 0;\r\n\t             size_t copied = 0, alen;\r\n\t             while (len != 0) {\r\n\t                       if ((alen = IOBUF_SIZE) > len) {\r\n\t                                alen = len;\r\n\t                       }\r\n\t                       ret = ...(10)...;\r\n\t                       if (alen != 0) {\r\n\t                                lock_mm(mm);\r\n\t                                {\r\n\t                                         if (copy_to_user(mm, base, buffer, alen)) {\r\n\t                                                   assert(len >= alen);\r\n\t                                                   base += alen, len -= alen, copied += alen;\r\n\t                                         }\r\n\t                                         else if (ret == 0) {\r\n\t                                                   ret = -E_INVAL;\r\n\t                                         }\r\n\t                                }\r\n\t                                unlock_mm(mm);\r\n\t                       }\r\n\t                       if (ret != 0 || alen == 0) {\r\n\t                                goto out;\r\n\t                       }\r\n\t             }\r\n\t    out:\r\n\t             kfree(buffer);\r\n\t             if (copied != 0) {\r\n\t                       return copied;\r\n\t             }\r\n\t             return ret;\r\n\t    }\r\n\t    ...\r\n\t    ---------------------------------\r\n\t    kern/fs/file.c\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    int\r\n\t    file_read(int fd, void base, size_t len, size_t copied_store) {\r\n\t             int ret;\r\n\t             struct file file;\r\n\t             copied_store = 0;\r\n\t             if ((ret = fd2file(fd, &file;)) != 0) {\r\n\t                       return ret;\r\n\t             }\r\n\t             if (!file->readable) {\r\n\t                       return -E_INVAL;\r\n\t             }\r\n\t             filemap_acquire(file);\r\n\t             struct iobuf __iob, iob = iobuf_init(&__iob, base, len, file->pos);\r\n\t             ret = vop_read(file->node, iob);\r\n\t             size_t copied = iobuf_used(iob);\r\n\t             if (file->status == FD_OPENED) {\r\n\t                       file->pos += copied;\r\n\t             }\r\n\t             copied_store = copied;\r\n\t             filemap_release(file);\r\n\t             return ret;\r\n\t    }\r\n\t    ...\r\n\t    ---------------------------------\r\n\t    ```\r\n    \r\n\r\n", "degree_of_difficulty": "1\r\n", "source": "网络\r\n", "answer": "解释", "type": "4\r\n", "options": "  \r\n"}