{"knowledge": "处理机调度。\r\n", "question": "调度器是操作系统内核中依据调度算法进行进程切换选择的模块。请完成如下任务。\r\n1）试描述步进调度算法(Stride Scheduling)的基本原理。\r\n2）请给出下面测试程序（user/priority.c）执行时的进程调度顺序。建议说明每次进程切换后当前执行进程的ID、lab6_priority、lab6\r\n_stride和已切换次数。\r\n    ```\r\n\t    kern/process/proc.h\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    struct proc_struct {\r\n\t        enum proc_state state;                      // Process state\r\n\t        int pid;                                    // Process ID\r\n\t        int runs;                                   // the running times of Proces\r\n\t        uintptr_t kstack;                           // Process kernel stack\r\n\t        volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?\r\n\t        struct proc_struct parent;                 // the parent process\r\n\t        struct mm_struct mm;                       // Process's memory management field\r\n\t        struct context context;                     // Switch here to run process\r\n\t        struct trapframe tf;                       // Trap frame for current interrupt\r\n\t        uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)\r\n\t        uint32_t flags;                             // Process flag\r\n\t        char name[PROC_NAME_LEN + 1];               // Process name\r\n\t        list_entry_t list_link;                     // Process link list\r\n\t        list_entry_t hash_link;                     // Process hash list\r\n\t        int exit_code;                              // exit code (be sent to parent proc)\r\n\t        uint32_t wait_state;                        // waiting state\r\n\t        struct proc_struct cptr, yptr, optr;     // relations between processes\r\n\t        struct run_queue rq;                       // running queue contains Process\r\n\t        list_entry_t run_link;                      // the entry linked in run queue\r\n\t        int time_slice;                             // time slice for occupying the CPU\r\n\t        skew_heap_entry_t lab6_run_pool;            // FOR LAB6 ONLY: the entry in the run pool\r\n\t        uint32_t lab6_stride;                       // FOR LAB6 ONLY: the current stride of the process\r\n\t        uint32_t lab6_priority;                     // FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)\r\n\t    };\r\n\t    user/priority.c\r\n\t    ---------------------------------\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #define TOTAL 6\r\n\t    / to get enough accuracy, MAX_TIME (the running time of each process) should >1000 mseconds. /\r\n\t    #define MAX_TIME  2000\r\n\t    unsigned int acc[TOTAL];\r\n\t    int status[TOTAL];\r\n\t    int pids[TOTAL];\r\n\t    static void\r\n\t    spin_delay(void)\r\n\t    {\r\n\t         int i;\r\n\t         volatile int j;\r\n\t         for (i = 0; i != 200; ++ i)\r\n\t         {\r\n\t              j = !j;\r\n\t         }\r\n\t    }\r\n\t    int\r\n\t    main(void) {\r\n\t         int i,time;\r\n\t         memset(pids, 0, sizeof(pids));\r\n\t         lab6_set_priority(TOTAL + 1);\r\n\t         for (i = 0; i < TOTAL; i ++) {\r\n\t              acc[i]=0;\r\n\t              if ((pids[i] = fork()) == 0) {\r\n\t                   lab6_set_priority(i + 1);\r\n\t                   acc[i] = 0;\r\n\t                   while (1) {\r\n\t                        spin_delay();\r\n\t                        ++ acc[i];\r\n\t                        if(acc[i]%4000==0) {\r\n\t                            if((time=gettime_msec())>MAX_TIME) {\r\n\t                                cprintf(\"child pid %d, acc %d, time %d\r\n\t\",getpid(),acc[i],time);\r\n\t                                exit(acc[i]);\r\n\t                            }\r\n\t                        }\r\n\t                   }\r\n\t              }\r\n\t              if (pids[i] < 0) {\r\n\t                   goto failed;\r\n\t              }\r\n\t         }\r\n\t         cprintf(\"main: fork ok,now need to wait pids.\r\n\t\");\r\n\t         for (i = 0; i < TOTAL; i ++) {\r\n\t             status[i]=0;\r\n\t             waitpid(pids[i],&status;[i]);\r\n\t             cprintf(\"main: pid %d, acc %d, time %d\r\n\t\",pids[i],status[i],gettime_msec());\r\n\t         }\r\n\t         cprintf(\"main: wait pids over\r\n\t\");\r\n\t         cprintf(\"stride sched correct result:\");\r\n\t         for (i = 0; i < TOTAL; i ++)\r\n\t         {\r\n\t             cprintf(\" %d\", (status[i]  2 / status[0] + 1) / 2);\r\n\t         }\r\n\t         cprintf(\"\r\n\t\");\r\n\t         return 0;\r\n\t    failed:\r\n\t         for (i = 0; i < TOTAL; i ++) {\r\n\t              if (pids[i] > 0) {\r\n\t                   kill(pids[i]);\r\n\t              }\r\n\t         }\r\n\t         panic(\"FAIL: T.T\r\n\t\");\r\n\t    }\r\n\t    ```\r\n    \r\n\r\n", "degree_of_difficulty": "1\r\n", "source": "网络\r\n", "answer": "解释", "type": "4\r\n", "options": "  \r\n"}