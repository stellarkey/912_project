{"knowledge": "文件系统。\r\n", "question": "在ucore中采用的文件系统是UNIX文件系统UFS的简化版本SFS。请完成如下任务。 1）描述UFS的多级间接索引文件（Multi-level\r\nIndexed Allocation）的存储结构； 2）补全下面文件系统代码。\r\n    ```\r\n\t    kern/fs/sfs/sfs.h\r\n\t    ---------------------------------\r\n\t    #ifndef __KERN_FS_SFS_SFS_H__\r\n\t    #define __KERN_FS_SFS_SFS_H__\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #include\r\n\t    #define SFS_MAGIC                                   0x2f8dbe2a              / magic number for sfs /\r\n\t    #define SFS_BLKSIZE                                 PGSIZE                  / size of block /\r\n\t    #define SFS_NDIRECT                                 12                      / # of direct blocks in inode /\r\n\t    #define SFS_MAX_INFO_LEN                            31                      / max length of infomation /\r\n\t    #define SFS_MAX_FNAME_LEN                           FS_MAX_FNAME_LEN        / max length of filename /\r\n\t    #define SFS_MAX_FILE_SIZE                           (1024UL  1024  128)   / max file size (128M) /\r\n\t    #define SFS_BLKN_SUPER                              0                       / block the superblock lives in /\r\n\t    #define SFS_BLKN_ROOT                               1                       / location of the root dir inode /\r\n\t    #define SFS_BLKN_FREEMAP                            2                       / 1st block of the freemap /\r\n\t    / # of bits in a block /\r\n\t    #define SFS_BLKBITS                                 (SFS_BLKSIZE  CHAR_BIT)\r\n\t    / # of entries in a block /\r\n\t    #define SFS_BLK_NENTRY                              (SFS_BLKSIZE / sizeof(uint32_t))\r\n\t    / file types /\r\n\t    #define SFS_TYPE_INVAL                              0       / Should not appear on disk /\r\n\t    #define SFS_TYPE_FILE                               1\r\n\t    #define SFS_TYPE_DIR                                2\r\n\t    #define SFS_TYPE_LINK                               3\r\n\t    /\r\n\t      On-disk superblock\r\n\t     /\r\n\t    struct sfs_super {\r\n\t        uint32_t magic;                                 / magic number, should be SFS_MAGIC /\r\n\t        uint32_t blocks;                                / # of blocks in fs /\r\n\t        uint32_t unused_blocks;                         / # of unused blocks in fs /\r\n\t        char info[SFS_MAX_INFO_LEN + 1];                / infomation for sfs  /\r\n\t    };\r\n\t    / inode (on disk) /\r\n\t    struct sfs_disk_inode {\r\n\t        uint32_t size;                                  / size of the file (in bytes) /\r\n\t        uint16_t type;                                  / one of SYS_TYPE_ above /\r\n\t        uint16_t nlinks;                                / # of hard links to this file /\r\n\t        uint32_t blocks;                                / # of blocks /\r\n\t        uint32_t direct[SFS_NDIRECT];                   / direct blocks /\r\n\t        uint32_t indirect;                              / indirect blocks /\r\n\t    //    uint32_t db_indirect;                           / double indirect blocks /\r\n\t    //   unused\r\n\t    };\r\n\t    / file entry (on disk) /\r\n\t    struct sfs_disk_entry {\r\n\t        uint32_t ino;                                   / inode number /\r\n\t        char name[SFS_MAX_FNAME_LEN + 1];               / file name /\r\n\t    };\r\n\t    #define sfs_dentry_size                             \\\r\n\t        sizeof(((struct sfs_disk_entry )0)->name)\r\n\t    / inode for sfs /\r\n\t    struct sfs_inode {\r\n\t        struct sfs_disk_inode din;                     / on-disk inode /\r\n\t        uint32_t ino;                                   / inode number /\r\n\t        bool dirty;                                     / true if inode modified /\r\n\t        int reclaim_count;                              / kill inode if it hits zero /\r\n\t        semaphore_t sem;                                / semaphore for din /\r\n\t        list_entry_t inode_link;                        / entry for linked-list in sfs_fs /\r\n\t        list_entry_t hash_link;                         / entry for hash linked-list in sfs_fs /\r\n\t    };\r\n\t    #define le2sin(le, member)                          \\\r\n\t        to_struct((le), struct sfs_inode, member)\r\n\t    / filesystem for sfs /\r\n\t    struct sfs_fs {\r\n\t        struct sfs_super super;                         / on-disk superblock /\r\n\t        struct device dev;                             / device mounted on /\r\n\t        struct bitmap freemap;                         / blocks in use are mared 0 /\r\n\t        bool super_dirty;                               / true if super/freemap modified /\r\n\t        void sfs_buffer;                               / buffer for non-block aligned io /\r\n\t        semaphore_t fs_sem;                             / semaphore for fs /\r\n\t        semaphore_t io_sem;                             / semaphore for io /\r\n\t        semaphore_t mutex_sem;                          / semaphore for link/unlink and rename /\r\n\t        list_entry_t inode_list;                        / inode linked-list /\r\n\t        list_entry_t hash_list;                        / inode hash linked-list /\r\n\t    };\r\n\t    / hash for sfs /\r\n\t    #define SFS_HLIST_SHIFT                             10\r\n\t    #define SFS_HLIST_SIZE                              (1 << SFS_HLIST_SHIFT)\r\n\t    #define sin_hashfn(x)                               (hash32(x, SFS_HLIST_SHIFT))\r\n\t    / size of freemap (in bits) /\r\n\t    #define sfs_freemap_bits(super)                     ROUNDUP((super)->blocks, SFS_BLKBITS)\r\n\t    / size of freemap (in blocks) /\r\n\t    #define sfs_freemap_blocks(super)                   ROUNDUP_DIV((super)->blocks, SFS_BLKBITS)\r\n\t    struct fs;\r\n\t    struct inode;\r\n\t    void sfs_init(void);\r\n\t    int sfs_mount(const char devname);\r\n\t    void lock_sfs_fs(struct sfs_fs sfs);\r\n\t    void lock_sfs_io(struct sfs_fs sfs);\r\n\t    void lock_sfs_mutex(struct sfs_fs sfs);\r\n\t    void unlock_sfs_fs(struct sfs_fs sfs);\r\n\t    void unlock_sfs_io(struct sfs_fs sfs);\r\n\t    void unlock_sfs_mutex(struct sfs_fs sfs);\r\n\t    int sfs_rblock(struct sfs_fs sfs, void buf, uint32_t blkno, uint32_t nblks);\r\n\t    int sfs_wblock(struct sfs_fs sfs, void buf, uint32_t blkno, uint32_t nblks);\r\n\t    int sfs_rbuf(struct sfs_fs sfs, void buf, size_t len, uint32_t blkno, off_t offset);\r\n\t    int sfs_wbuf(struct sfs_fs sfs, void buf, size_t len, uint32_t blkno, off_t offset);\r\n\t    int sfs_sync_super(struct sfs_fs sfs);\r\n\t    int sfs_sync_freemap(struct sfs_fs sfs);\r\n\t    int sfs_clear_block(struct sfs_fs sfs, uint32_t blkno, uint32_t nblks);\r\n\t    int sfs_load_inode(struct sfs_fs sfs, struct inode node_store, uint32_t ino);\r\n\t    #endif / !__KERN_FS_SFS_SFS_H__ /\r\n\t    kern/fs/sfs/sfs_inode.c\r\n\t    ---------------------------------\r\n\t    static int\r\n\t    sfs_bmap_get_sub_nolock(struct sfs_fs sfs, uint32_t entp, uint32_t index, bool create, uint32_t ino_store) {\r\n\t        assert(index < SFS_BLK_NENTRY);\r\n\t        int ret;\r\n\t        uint32_t ent, ino = 0;\r\n\t        off_t offset = index  sizeof(uint32_t);\r\n\t        if ((ent = entp) != 0) {\r\n\t            if ((ret = sfs_rbuf(sfs, &ino;, sizeof(uint32_t), ent, offset)) != 0) {\r\n\t                ___(1)___\r\n\t                return ret;\r\n\t            }\r\n\t            if (ino != 0 || !create) {\r\n\t                goto out;\r\n\t            }\r\n\t        }\r\n\t        else {\r\n\t            if (!create) {\r\n\t                goto out;\r\n\t            }\r\n\t            if ((ret = sfs_block_alloc(sfs, &ent;)) != 0) {\r\n\t                return ret;\r\n\t            }\r\n\t        }\r\n\t        if ((ret = sfs_block_alloc(sfs, &ino;)) != 0) {\r\n\t            goto failed_cleanup;\r\n\t        }\r\n\t        if ((ret = sfs_wbuf(sfs, &ino;, sizeof(uint32_t), ent, offset)) != 0) {\r\n\t             ___(2)___\r\n\t            sfs_block_free(sfs, ino);\r\n\t            goto failed_cleanup;\r\n\t        }\r\n\t    out:\r\n\t        if (ent != entp) {\r\n\t            entp = ent;\r\n\t        }\r\n\t        ino_store = ino;\r\n\t        return 0;\r\n\t    failed_cleanup:\r\n\t        if (ent != entp) {\r\n\t            sfs_block_free(sfs, ent);\r\n\t        }\r\n\t        return ret;\r\n\t    }\r\n\t    static int\r\n\t    sfs_bmap_get_nolock(struct sfs_fs sfs, struct sfs_inode sin, uint32_t index, bool create, uint32_t ino_store) {\r\n\t        struct sfs_disk_inode din = sin->din;\r\n\t        int ret;\r\n\t        uint32_t ent, ino;\r\n\t        if (index < SFS_NDIRECT) {\r\n\t             ___(3)___\r\n\t            if ((ino = din->direct[index]) == 0 && create) {\r\n\t                if ((ret = sfs_block_alloc(sfs, &ino;)) != 0) {\r\n\t                    return ret;\r\n\t                }\r\n\t                din->direct[index] = ino;\r\n\t                sin->dirty = 1;\r\n\t            }\r\n\t            goto out;\r\n\t        }\r\n\t        index -= SFS_NDIRECT;\r\n\t             ___(4)___\r\n\t        if (index < SFS_BLK_NENTRY) {\r\n\t            ent = din->indirect;\r\n\t            if ((ret = sfs_bmap_get_sub_nolock(sfs, &ent;, index, create, &ino;)) != 0) {\r\n\t             ___(5)___\r\n\t                return ret;\r\n\t            }\r\n\t            if (ent != din->indirect) {\r\n\t                assert(din->indirect == 0);\r\n\t                din->indirect = ent;\r\n\t                sin->dirty = 1;\r\n\t            }\r\n\t            goto out;\r\n\t        }\r\n\t        index -= SFS_BLK_NENTRY;\r\n\t             ___(6)___\r\n\t        if ((ent = ino) != 0) {\r\n\t            if ((ret = sfs_bmap_get_sub_nolock(sfs, &ent;, index % SFS_BLK_NENTRY, create, &ino;)) != 0) {\r\n\t                return ret;\r\n\t            }\r\n\t        }\r\n\t    out:\r\n\t        assert(ino == 0 || sfs_block_inuse(sfs, ino));\r\n\t        ino_store = ino;\r\n\t        return 0;\r\n\t    }\r\n\t    static int\r\n\t    sfs_io_nolock(struct sfs_fs sfs, struct sfs_inode sin, void buf, off_t offset, size_t alenp, bool write) {\r\n\t        struct sfs_disk_inode din = sin->din;\r\n\t        assert(din->type != SFS_TYPE_DIR);\r\n\t        off_t endpos = offset + alenp, blkoff;\r\n\t        alenp = 0;\r\n\t        if (offset < 0 || offset >= SFS_MAX_FILE_SIZE || offset > endpos) {\r\n\t            return -E_INVAL;\r\n\t        }\r\n\t        if (offset == endpos) {\r\n\t            return 0;\r\n\t        }\r\n\t        if (endpos > SFS_MAX_FILE_SIZE) {\r\n\t            endpos = SFS_MAX_FILE_SIZE;\r\n\t        }\r\n\t        if (!write) {\r\n\t            if (offset >= din->size) {\r\n\t                return 0;\r\n\t            }\r\n\t            if (endpos > din->size) {\r\n\t                endpos = din->size;\r\n\t            }\r\n\t        }\r\n\t        int (sfs_buf_op)(struct sfs_fs sfs, void buf, size_t len, uint32_t blkno, off_t offset);\r\n\t        int (sfs_block_op)(struct sfs_fs sfs, void buf, uint32_t blkno, uint32_t nblks);\r\n\t        if (write) {\r\n\t            sfs_buf_op = sfs_wbuf, sfs_block_op = sfs_wblock;\r\n\t             ___(7)___\r\n\t        }\r\n\t        else {\r\n\t            sfs_buf_op = sfs_rbuf, sfs_block_op = sfs_rblock;\r\n\t        }\r\n\t        int ret = 0;\r\n\t        size_t size, alen = 0;\r\n\t        uint32_t ino;\r\n\t        uint32_t blkno = offset / SFS_BLKSIZE;\r\n\t        uint32_t nblks = endpos / SFS_BLKSIZE - blkno;\r\n\t        if ((blkoff = offset % SFS_BLKSIZE) != 0) {\r\n\t            size = (nblks != 0) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);\r\n\t            if ((ret = sfs_bmap_load_nolock(sfs, sin, blkno, &ino;)) != 0) {\r\n\t                goto out;\r\n\t            }\r\n\t            if ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != 0) {\r\n\t             ___(8)___\r\n\t                goto out;\r\n\t            }\r\n\t            alen += size;\r\n\t            if (nblks == 0) {\r\n\t                goto out;\r\n\t            }\r\n\t            buf += size, blkno ++, nblks --;\r\n\t        }\r\n\t        size = SFS_BLKSIZE;\r\n\t        while (nblks != 0) {\r\n\t            if ((ret = sfs_bmap_load_nolock(sfs, sin, blkno, &ino;)) != 0) {\r\n\t                goto out;\r\n\t            }\r\n\t            if ((ret = sfs_block_op(sfs, buf, ino, 1)) != 0) {\r\n\t                goto out;\r\n\t            }\r\n\t            alen += size, buf += size, blkno ++, nblks --;\r\n\t        }\r\n\t        if ((size = endpos % SFS_BLKSIZE) != 0) {\r\n\t            if ((ret = sfs_bmap_load_nolock(sfs, sin, blkno, &ino;)) != 0) {\r\n\t                goto out;\r\n\t            }\r\n\t            if ((ret = sfs_buf_op(sfs, buf, size, ino, 0)) != 0) {\r\n\t                goto out;\r\n\t            }\r\n\t            alen += size;\r\n\t        }\r\n\t    out:\r\n\t        alenp = alen;\r\n\t        if (offset + alen > sin->din->size) {\r\n\t            sin->din->size = offset + alen;\r\n\t            sin->dirty = 1;\r\n\t        }\r\n\t        return ret;\r\n\t    }\r\n\t    static int\r\n\t    sfs_read(struct inode node, struct iobuf iob) {\r\n\t        return sfs_io(node, iob, 0);\r\n\t             ___(9)___\r\n\t    }\r\n\t    static int\r\n\t    sfs_write(struct inode node, struct iobuf iob) {\r\n\t        return sfs_io(node, iob, 1);\r\n\t             ___(10)___\r\n\t    }\r\n\t    static inline int\r\n\t    sfs_io(struct inode node, struct iobuf iob, bool write) {\r\n\t        struct sfs_fs sfs = fsop_info(vop_fs(node), sfs);\r\n\t        struct sfs_inode sin = vop_info(node, sfs_inode);\r\n\t        int ret;\r\n\t        lock_sin(sin);\r\n\t        {\r\n\t            size_t alen = iob->io_resid;\r\n\t            ret = sfs_io_nolock(sfs, sin, iob->io_base, iob->io_offset, &alen;, write);\r\n\t             ___(11)___\r\n\t            if (alen != 0) {\r\n\t                iobuf_skip(iob, alen);\r\n\t            }\r\n\t        }\r\n\t        unlock_sin(sin);\r\n\t        return ret;\r\n\t    }\r\n\t    static const struct inode_ops sfs_node_dirops = {\r\n\t        .vop_magic                      = VOP_MAGIC,\r\n\t        .vop_open                       = sfs_opendir,\r\n\t        .vop_close                      = sfs_close,\r\n\t        .vop_read                       = NULL_VOP_ISDIR,\r\n\t        .vop_write                      = NULL_VOP_ISDIR,\r\n\t        .vop_fstat                      = sfs_fstat,\r\n\t        .vop_fsync                      = sfs_fsync,\r\n\t        .vop_mkdir                      = NULL_VOP_UNIMP,\r\n\t        .vop_link                       = NULL_VOP_UNIMP,\r\n\t        .vop_rename                     = NULL_VOP_UNIMP,\r\n\t        .vop_readlink                   = NULL_VOP_ISDIR,\r\n\t        .vop_symlink                    = NULL_VOP_UNIMP,\r\n\t        .vop_namefile                   = sfs_namefile,\r\n\t        .vop_getdirentry                = sfs_getdirentry,\r\n\t        .vop_reclaim                    = sfs_reclaim,\r\n\t        .vop_ioctl                      = NULL_VOP_INVAL,\r\n\t        .vop_gettype                    = sfs_gettype,\r\n\t        .vop_tryseek                    = NULL_VOP_ISDIR,\r\n\t        .vop_truncate                   = NULL_VOP_UNIMP,\r\n\t        .vop_create                     = NULL_VOP_UNIMP,\r\n\t        .vop_unlink                     = NULL_VOP_UNIMP,\r\n\t        .vop_lookup                     = sfs_lookup,\r\n\t        .vop_lookup_parent              = NULL_VOP_UNIMP,\r\n\t    };\r\n\t    static const struct inode_ops sfs_node_fileops = {\r\n\t        .vop_magic                      = VOP_MAGIC,\r\n\t        .vop_open                       = sfs_openfile,\r\n\t        .vop_close                      = sfs_close,\r\n\t        .vop_read                       = sfs_read,\r\n\t        .vop_write                      = sfs_write,\r\n\t        .vop_fstat                      = sfs_fstat,\r\n\t        .vop_fsync                      = sfs_fsync,\r\n\t        .vop_mkdir                      = NULL_VOP_NOTDIR,\r\n\t        .vop_link                       = NULL_VOP_NOTDIR,\r\n\t        .vop_rename                     = NULL_VOP_NOTDIR,\r\n\t        .vop_readlink                   = NULL_VOP_NOTDIR,\r\n\t        .vop_symlink                    = NULL_VOP_NOTDIR,\r\n\t        .vop_namefile                   = NULL_VOP_NOTDIR,\r\n\t        .vop_getdirentry                = NULL_VOP_NOTDIR,\r\n\t        .vop_reclaim                    = sfs_reclaim,\r\n\t        .vop_ioctl                      = NULL_VOP_INVAL,\r\n\t        .vop_gettype                    = sfs_gettype,\r\n\t        .vop_tryseek                    = sfs_tryseek,\r\n\t        .vop_truncate                   = sfs_truncfile,\r\n\t        .vop_create                     = NULL_VOP_NOTDIR,\r\n\t        .vop_unlink                     = NULL_VOP_NOTDIR,\r\n\t        .vop_lookup                     = NULL_VOP_NOTDIR,\r\n\t        .vop_lookup_parent              = NULL_VOP_NOTDIR,\r\n\t    };\r\n\t    ```\r\n    \r\n\r\n", "degree_of_difficulty": "1\r\n", "source": "网络\r\n", "answer": "解释", "type": "4\r\n", "options": "  \r\n"}