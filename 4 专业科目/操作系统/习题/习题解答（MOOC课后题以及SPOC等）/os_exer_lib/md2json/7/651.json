{"knowledge": "缺页中断。\r\n", "question": "在虚拟存储系统中，当由虚拟地址找不到对应的物理地址时，会产生缺页故障。请完成如下任务。 1）描述缺页故障（page_fault）的处理流程；\r\n2）补全下面缺页处理中所缺代码。\r\n    ```\r\n\t    kern/trap/trap.c\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    static int\r\n\t    pgfault_handler(struct trapframe tf) {\r\n\t        extern struct mm_struct check_mm_struct;\r\n\t        if(check_mm_struct !=NULL) { //used for test check_swap\r\n\t                print_pgfault(tf);\r\n\t            }\r\n\t        struct mm_struct mm;\r\n\t        if (check_mm_struct != NULL) {\r\n\t            assert(current == idleproc);\r\n\t            mm = check_mm_struct;\r\n\t        }\r\n\t        else {\r\n\t            if (current == NULL) {\r\n\t                print_trapframe(tf);\r\n\t                print_pgfault(tf);\r\n\t                panic(\"unhandled page fault.\r\n\t\");\r\n\t            }\r\n\t            mm = current->mm;\r\n\t        }\r\n\t        return do_pgfault(mm, tf->tf_err, rcr2());\r\n\t             ____(1)____\r\n\t    }\r\n\t    ...\r\n\t    static void\r\n\t    trap_dispatch(struct trapframe tf) {\r\n\t        char c;\r\n\t        int ret=0;\r\n\t        switch (tf->tf_trapno) {\r\n\t        case T_DEBUG:\r\n\t        case T_BRKPT:\r\n\t            debug_monitor(tf);\r\n\t            break;\r\n\t        case T_PGFLT:\r\n\t            if ((ret = pgfault_handler(tf)) != 0) {\r\n\t             ___(2)___\r\n\t                print_trapframe(tf);\r\n\t                if (current == NULL) {\r\n\t                    panic(\"handle pgfault failed. ret=%d\r\n\t\", ret);\r\n\t                }\r\n\t                else {\r\n\t                    if (trap_in_kernel(tf)) {\r\n\t                        panic(\"handle pgfault failed in kernel mode. ret=%d\r\n\t\", ret);\r\n\t                    }\r\n\t                    cprintf(\"killed by kernel.\r\n\t\");\r\n\t                    panic(\"handle user mode pgfault failed. ret=%d\r\n\t\", ret);\r\n\t                    do_exit(-E_KILLED);\r\n\t                }\r\n\t            }\r\n\t            break;\r\n\t        case T_SYSCALL:\r\n\t            syscall();\r\n\t            break;\r\n\t        case IRQ_OFFSET + IRQ_TIMER:\r\n\t    //    LAB3 : If some page replacement algorithm need tick to change the priority of pages,\r\n\t    //    then you can add code here.\r\n\t            ticks ++;\r\n\t            assert(current != NULL);\r\n\t            run_timer_list();\r\n\t            break;\r\n\t        case IRQ_OFFSET + IRQ_COM1:\r\n\t        case IRQ_OFFSET + IRQ_KBD:\r\n\t            if ((c = cons_getc()) == 13) {\r\n\t                debug_monitor(tf);\r\n\t            }\r\n\t            else {\r\n\t                cprintf(\"%s [%03d] %c\r\n\t\",\r\n\t                        (tf->tf_trapno != IRQ_OFFSET + IRQ_KBD) ? \"serial\" : \"kbd\", c, c);\r\n\t            }\r\n\t            break;\r\n\t        case IRQ_OFFSET + IRQ_IDE1:\r\n\t        case IRQ_OFFSET + IRQ_IDE2:\r\n\t            / do nothing /\r\n\t            break;\r\n\t        default:\r\n\t            print_trapframe(tf);\r\n\t            if (current != NULL) {\r\n\t                cprintf(\"unhandled trap.\r\n\t\");\r\n\t                do_exit(-E_KILLED);\r\n\t            }\r\n\t            // in kernel, it must be a mistake\r\n\t            panic(\"unexpected trap in kernel.\r\n\t\");\r\n\t        }\r\n\t    }\r\n\t    kern/mm/vmm.c\r\n\t    ---------------------------------\r\n\t    // do_pgfault - interrupt handler to process the page fault execption\r\n\t    int\r\n\t    do_pgfault(struct mm_struct mm, uint32_t error_code, uintptr_t addr) {\r\n\t        int ret = -E_INVAL;\r\n\t        struct vma_struct vma = find_vma(mm, addr);\r\n\t        pgfault_num++;\r\n\t        if (vma == NULL ) {\r\n\t            cprintf(\"not valid addr %x, and  can not find it vma %x\r\n\t\", addr, vma);\r\n\t            goto failed;\r\n\t        }\r\n\t        else if (vma->vm_start > addr) {\r\n\t            cprintf(\"not valid addr %x, and  can not find it vma range[%x, %x]\r\n\t\", addr, vma->vm_start, vma->vm_end);\r\n\t            goto failed;\r\n\t        }\r\n\t        cprintf(\"valid addr %x, and find it in vma range[%x, %x]\r\n\t\", addr, vma->vm_start, vma->vm_end);\r\n\t        switch (error_code & 3) {\r\n\t        default:\r\n\t                / default is 3: write, present /\r\n\t        case 2: / write, not present /\r\n\t            if (!(vma->vm_flags & VM_WRITE)) {\r\n\t                cprintf(\"write, not present in do_pgfault failed\r\n\t\");\r\n\t                goto failed;\r\n\t            }\r\n\t            break;\r\n\t        case 1: / read, present /\r\n\t            cprintf(\"read, present in do_pgfault failed\r\n\t\");\r\n\t            goto failed;\r\n\t        case 0: / read, not present /\r\n\t            if (!(vma->vm_flags & (VM_READ | VM_EXEC))) {\r\n\t                cprintf(\"read, not present in do_pgfault failed\r\n\t\");\r\n\t                goto failed;\r\n\t            }\r\n\t        }\r\n\t        uint32_t perm = PTE_U;\r\n\t        if (vma->vm_flags & VM_WRITE) {\r\n\t            perm |= PTE_W;\r\n\t        }\r\n\t        addr = ROUNDDOWN(addr, PGSIZE);\r\n\t        ret = -E_NO_MEM;\r\n\t        pte_t ptep;\r\n\t        // try to find a pte, if pte's PT(Page Table) isn't existed, then create a PT.\r\n\t        // (notice the 3th parameter '1')\r\n\t        if ((ptep = get_pte(mm->pgdir, addr, 1)) == NULL) {\r\n\t            cprintf(\"get_pte in do_pgfault failed\r\n\t\");\r\n\t            goto failed;\r\n\t        }\r\n\t        if (ptep == 0) { // if the phy addr isn't exist, then alloc a page & map the phy addr with logical addr\r\n\t            if (pgdir_alloc_page(mm->pgdir, addr, perm) == NULL) {\r\n\t             ___(3)___\r\n\t                cprintf(\"pgdir_alloc_page in do_pgfault failed\r\n\t\");\r\n\t                goto failed;\r\n\t            }\r\n\t        }\r\n\t        else {\r\n\t            struct Page page=NULL;\r\n\t            cprintf(\"do pgfault: ptep %x, pte %x\r\n\t\",ptep, ptep);\r\n\t            if (ptep & PTE_P) {\r\n\t                page = pte2page(ptep);\r\n\t             ___(4)___\r\n\t            } else{\r\n\t               // if this pte is a swap entry, then load data from disk to a page with phy addr\r\n\t               // and call page_insert to map the phy addr with logical addr\r\n\t               if(swap_init_ok) {\r\n\t                   if ((ret = swap_in(mm, addr, &page;)) != 0) {\r\n\t             ___(5)___\r\n\t                       cprintf(\"swap_in in do_pgfault failed\r\n\t\");\r\n\t                       goto failed;\r\n\t                   }\r\n\t               }\r\n\t               else {\r\n\t                cprintf(\"no swap_init_ok but ptep is %x, failed\r\n\t\",ptep);\r\n\t                goto failed;\r\n\t               }\r\n\t           }\r\n\t           page_insert(mm->pgdir, page, addr, perm);\r\n\t           swap_map_swappable(mm, addr, page, 1);\r\n\t       }\r\n\t       ret = 0;\r\n\t    failed:\r\n\t        return ret;\r\n\t    }\r\n\t    kern/mm/swap.c\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    int\r\n\t    swap_out(struct mm_struct mm, int n, int in_tick)\r\n\t    {\r\n\t         int i;\r\n\t         for (i = 0; i != n; ++ i)\r\n\t         {\r\n\t              uintptr_t v;\r\n\t              //struct Page ptr_page=NULL;\r\n\t              struct Page page;\r\n\t              // cprintf(\"i %d, SWAP: call swap_out_victim\r\n\t\",i);\r\n\t              int r = sm->swap_out_victim(mm, &page;, in_tick);\r\n\t              if (r != 0) {\r\n\t                      cprintf(\"i %d, swap_out: call swap_out_victim failed\r\n\t\",i);\r\n\t                      break;\r\n\t              }\r\n\t              //assert(!PageReserved(page));\r\n\t              //cprintf(\"SWAP: choose victim page 0x%08x\r\n\t\", page);\r\n\t              v=page->pra_vaddr;\r\n\t              pte_t ptep = get_pte(mm->pgdir, v, 0);\r\n\t              assert((ptep & PTE_P) != 0);\r\n\t              if (swapfs_write( (page->pra_vaddr/PGSIZE+1)<<8, page) != 0) {\r\n\t             ___(6)___\r\n\t                        cprintf(\"SWAP: failed to save\r\n\t\");\r\n\t                        sm->map_swappable(mm, v, page, 0);\r\n\t                        continue;\r\n\t              }\r\n\t              else {\r\n\t                        cprintf(\"swap_out: i %d, store page in vaddr 0x%x to disk swap entry %d\r\n\t\", i, v, page->pra_vaddr/PGSIZE+1);\r\n\t                        ptep = (page->pra_vaddr/PGSIZE+1)<<8;\r\n\t                        free_page(page);\r\n\t              }\r\n\t              tlb_invalidate(mm->pgdir, v);\r\n\t         }\r\n\t         return i;\r\n\t    }\r\n\t    int\r\n\t    swap_in(struct mm_struct mm, uintptr_t addr, struct Page ptr_result)\r\n\t    {\r\n\t         struct Page result = alloc_page();\r\n\t         assert(result!=NULL);\r\n\t         pte_t ptep = get_pte(mm->pgdir, addr, 0);\r\n\t         // cprintf(\"SWAP: load ptep %x swap entry %d to vaddr 0x%08x, page %x, No %d\r\n\t\", ptep, (ptep)>>8, addr, result, (result-pages));\r\n\t         int r;\r\n\t         if ((r = swapfs_read((ptep), result)) != 0)\r\n\t             ___(7)___\r\n\t         {\r\n\t            assert(r!=0);\r\n\t         }\r\n\t         cprintf(\"swap_in: load disk swap entry %d with swap_page in vadr 0x%x free_area.nr_free %d\r\n\t\", (ptep)>>8, addr, free_area.nr_free);\r\n\t         ptr_result=result;\r\n\t         return 0;\r\n\t    }\r\n\t    kern/mm/pmm.h\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    #define alloc_page() alloc_pages(1)\r\n\t    #define free_page(page) free_pages(page, 1)\r\n\t    kern/mm/pmm.c\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    // pgdir_alloc_page - call alloc_page & page_insert functions to\r\n\t    //                  - allocate a page size memory & setup an addr map\r\n\t    //                  - pa<->la with linear address la and the PDT pgdir\r\n\t    struct Page \r\n\t    pgdir_alloc_page(pde_t pgdir, uintptr_t la, uint32_t perm) {\r\n\t        struct Page page = alloc_page();\r\n\t        if (page != NULL) {\r\n\t            if (page_insert(pgdir, page, la, perm) != 0) {\r\n\t                free_page(page);\r\n\t                return NULL;\r\n\t            }\r\n\t            if (swap_init_ok){\r\n\t                if(check_mm_struct!=NULL) {\r\n\t                    swap_map_swappable(check_mm_struct, la, page, 0);\r\n\t                    page->pra_vaddr=la;\r\n\t                    assert(page_ref(page) == 1);\r\n\t                    //cprintf(\"get No. %d  page: pra_vaddr %x, pra_link.prev %x, pra_link_next %x in pgdir_alloc_page\r\n\t\", (page-pages), page->pra_vaddr,page->pra_page_link.prev, page->pra_page_link.next);\r\n\t                }\r\n\t                else  {  //now current is existed, should fix it in the future\r\n\t                    //swap_map_swappable(current->mm, la, page, 0);\r\n\t                    //page->pra_vaddr=la;\r\n\t                    //assert(page_ref(page) == 1);\r\n\t                    //panic(\"pgdir_alloc_page: no pages. now current is existed, should fix it in the future\r\n\t\");\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        return page;\r\n\t    }\r\n\t    kern/fs/swapfs.c\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    int\r\n\t    swapfs_read(swap_entry_t entry, struct Page page) {\r\n\t        return ide_read_secs(SWAP_DEV_NO, swap_offset(entry)  PAGE_NSECT, page2kva(page), PAGE_NSECT);\r\n\t    }\r\n\t    int\r\n\t    swapfs_write(swap_entry_t entry, struct Page page) {\r\n\t        return ide_write_secs(SWAP_DEV_NO, swap_offset(entry)  PAGE_NSECT, page2kva(page), PAGE_NSECT);\r\n\t    }\r\n\t    kern/mm/swap_fifo.c\r\n\t    ---------------------------------\r\n\t    ...\r\n\t    struct swap_manager swap_manager_fifo =\r\n\t    {\r\n\t         .name            = \"fifo swap manager\",\r\n\t         .init            = &_fifo_init,\r\n\t         .init_mm         = &_fifo_init_mm,\r\n\t         .tick_event      = &_fifo_tick_event,\r\n\t         .map_swappable   = &_fifo_map_swappable,\r\n\t         .set_unswappable = &_fifo_set_unswappable,\r\n\t         .swap_out_victim = &_fifo_swap_out_victim,\r\n\t         .check_swap      = &_fifo_check_swap,\r\n\t    };\r\n\t    ```\r\n    \r\n\r\n", "degree_of_difficulty": "1\r\n", "source": "网络\r\n", "answer": "1）缺页故障的处理流程：每点2分，共8分； 中断、权限检查、分配空闲页面并加载、没有空闲页面时的转换 2）7个填空，每个1分，变量不对扣0.5分，共7分；", "type": "4\r\n", "options": "  \r\n"}