{
    "status":"ok",
    "knowledge":[
        "启动和中断处理实验"
    ],
    "degree_of_difficulty":1,
    "explain":"    ```\n    void\n    print_stackframe(void) {\n         / LAB1 YOUR CODE : STEP 1 /\n         / (1) call read_ebp() to get the value of ebp. the type is (uint32_t);\n           (2) call read_eip() to get the value of eip. the type is (uint32_t);\n           (3) from 0 .. STACKFRAME_DEPTH\n              (3.1) printf value of ebp, eip\n              (3.2) (uint32_t)calling arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4]\n              (3.3) cprintf(\"\n\");\n              (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.\n              (3.5) popup a calling stackframe\n                     NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]\n                             the calling funciton's ebp = ss:[ebp]\n          /\n        uint32_t ebp = read_ebp(), eip = read_eip();\n        int i, j;\n        for (i = 0; ebp != 0 && i < STACKFRAME_DEPTH; i ++) {\n            cprintf(\"ebp:0x%08x eip:0x%08x args:\", ebp, eip);\n            uint32_t args = (uint32_t )ebp + 2;\n            for (j = 0; j < 4; j ++) {\n                cprintf(\"0x%08x \", args[j]);\n            }\n            cprintf(\"\n\");\n            print_debuginfo(eip - 1);\n            eip = ((uint32_t )ebp)[1];\n            ebp = ((uint32_t )ebp)[0];\n        }\n    }\n    ```\n\n",
    "question":"(20140410-2-期中考试试题v4a答案.docx)函数调用\n（15分）为实现函数的调用和返回功能，X86指令集中提供了call和ret两条指令。为在操作系统内核执行过程中分析了解函数函数的嵌套调用关系，ucore中实\n现了函数print_stackframe，用于跟踪函数调用堆栈中记录的返回地址。如果能够正确实现此函数，它将在qemu模拟器中得到类似如下的输出：\n    ```\n\t    ……\n\t    ebp:0x00007b28 eip:0x00100992 args:0x00010094 0x00010094 0x00007b58 0x00100096\n\t        kern/debug/kdebug.c:305: print_stackframe+22\n\t    ebp:0x00007b38 eip:0x00100c79 args:0x00000000 0x00000000 0x00000000 0x00007ba8\n\t        kern/debug/kmonitor.c:125: mon_backtrace+10\n\t    ebp:0x00007b58 eip:0x00100096 args:0x00000000 0x00007b80 0xffff0000 0x00007b84\n\t        kern/init/init.c:48: grade_backtrace2+33\n\t    ebp:0x00007b78 eip:0x001000bf args:0x00000000 0xffff0000 0x00007ba4 0x00000029\n\t        kern/init/init.c:53: grade_backtrace1+38\n\t    ebp:0x00007b98 eip:0x001000dd args:0x00000000 0x00100000 0xffff0000 0x0000001d\n\t        kern/init/init.c:58: grade_backtrace0+23\n\t    ebp:0x00007bb8 eip:0x00100102 args:0x0010353c 0x00103520 0x00001308 0x00000000\n\t        kern/init/init.c:63: grade_backtrace+34\n\t    ebp:0x00007be8 eip:0x00100059 args:0x00000000 0x00000000 0x00000000 0x00007c53\n\t        kern/init/init.c:28: kern_init+88\n\t    ebp:0x00007bf8 eip:0x00007d73 args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8\n\t    : -- 0x00007d72 –\n\t    ……\n\t    ```\n\t请回答如下问题。\n\t1) 描述函数调用和返回指令的执行过程。\n\t2) ucore中的函数调用参数是如何从调用函数（caller）传递给被调用函数（callee）的。\n\t3) 补全函数调用堆栈跟踪函数print_stackframe。\n\t    ```\n\t    //=========/kern/debug/kdebug.c=========\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #include\n\t    #define STACKFRAME_DEPTH 20\n\t    extern const struct stab __STAB_BEGIN__[];  // beginning of stabs table\n\t    extern const struct stab __STAB_END__[];    // end of stabs table\n\t    extern const char __STABSTR_BEGIN__[];      // beginning of string table\n\t    extern const char __STABSTR_END__[];        // end of string table\n\t    / debug information about a particular instruction pointer /\n\t    struct eipdebuginfo {\n\t        const char eip_file;                   // source code filename for eip\n\t        int eip_line;                           // source code line number for eip\n\t        const char eip_fn_name;                // name of function containing eip\n\t        int eip_fn_namelen;                     // length of function's name\n\t        uintptr_t eip_fn_addr;                  // start address of function\n\t        int eip_fn_narg;                        // number of function arguments\n\t    };\n\t    / \n\t      stab_binsearch - according to the input, the initial value of\n\t      range [@region_left, @region_right], find a single stab entry\n\t      that includes the address @addr and matches the type @type,\n\t      and then save its boundary to the locations that pointed\n\t      by @region_left and @region_right.\n\t     \n\t      Some stab types are arranged in increasing order by instruction address.\n\t      For example, N_FUN stabs (stab entries with n_type == N_FUN), which\n\t      mark functions, and N_SO stabs, which mark source files.\n\t     \n\t      Given an instruction address, this function finds the single stab entry\n\t      of type @type that contains that address.\n\t     \n\t      The search takes place within the range [@region_left, @region_right].\n\t      Thus, to search an entire set of N stabs, you might do:\n\t     \n\t           left = 0;\n\t           right = N - 1;    (rightmost stab)\n\t           stab_binsearch(stabs, &left;, &right;, type, addr);\n\t     \n\t      The search modifies region_left and region_right to bracket the @addr.\n\t      @region_left points to the matching stab that contains @addr,\n\t      and @region_right points just before the next stab.\n\t      If @region_left > region_right, then @addr is not contained in any\n\t      matching stab.\n\t     \n\t      For example, given these N_SO stabs:\n\t           Index  Type   Address\n\t           0      SO     f0100000\n\t           13     SO     f0100040\n\t           117    SO     f0100176\n\t           118    SO     f0100178\n\t           555    SO     f0100652\n\t           556    SO     f0100654\n\t           657    SO     f0100849\n\t      this code:\n\t           left = 0, right = 657;\n\t           stab_binsearch(stabs, &left;, &right;, N_SO, 0xf0100184);\n\t      will exit setting left = 118, right = 554.\n\t      /\n\t    static void\n\t    stab_binsearch(const struct stab stabs, int region_left, int region_right,\n\t               int type, uintptr_t addr) {\n\t        ……\n\t    }\n\t    / \n\t      debuginfo_eip - Fill in the @info structure with information about\n\t      the specified instruction address, @addr.  Returns 0 if information\n\t      was found, and negative if not.  But even if it returns negative it\n\t      has stored some information into 'info'.\n\t      /\n\t    int\n\t    debuginfo_eip(uintptr_t addr, struct eipdebuginfo info) {\n\t    …..\n\t    }\n\t    / \n\t      print_kerninfo - print the information about kernel, including the location\n\t      of kernel entry, the start addresses of data and text segements, the start\n\t      address of free memory and how many memory that kernel has used.\n\t      /\n\t    void\n\t    print_kerninfo(void) {\n\t        extern char etext[], edata[], end[], kern_init[];\n\t        cprintf(\"Special kernel symbols:\n\t\");\n\t        cprintf(\"  entry  0x%08x (phys)\n\t\", kern_init);\n\t        cprintf(\"  etext  0x%08x (phys)\n\t\", etext);\n\t        cprintf(\"  edata  0x%08x (phys)\n\t\", edata);\n\t        cprintf(\"  end    0x%08x (phys)\n\t\", end);\n\t        cprintf(\"Kernel executable memory footprint: %dKB\n\t\", (end - kern_init + 1023)/1024);\n\t    }\n\t    / \n\t      print_debuginfo - read and print the stat information for the address @eip,\n\t      and info.eip_fn_addr should be the first address of the related function.\n\t      /\n\t    void\n\t    print_debuginfo(uintptr_t eip) {\n\t        struct eipdebuginfo info;\n\t        if (debuginfo_eip(eip, &info;) != 0) {\n\t            cprintf(\"    : -- 0x%08x --\n\t\", eip);\n\t        }\n\t        else {\n\t            char fnname[256];\n\t            int j;\n\t            for (j = 0; j < info.eip_fn_namelen; j ++) {\n\t                fnname[j] = info.eip_fn_name[j];\n\t            }\n\t            fnname[j] = '\u0000';\n\t            cprintf(\"    %s:%d: %s+%d\n\t\", info.eip_file, info.eip_line,\n\t                    fnname, eip - info.eip_fn_addr);\n\t        }\n\t    }\n\t    static __noinline uint32_t\n\t    read_eip(void) {\n\t        uint32_t eip;\n\t        asm volatile(\"movl 4(%%ebp), %0\" : \"=r\" (eip));\n\t        return eip;\n\t    }\n\t    / \n\t      print_stackframe - print a list of the saved eip values from the nested 'call'\n\t      instructions that led to the current point of execution\n\t     \n\t      The x86 stack pointer, namely esp, points to the lowest location on the stack\n\t      that is currently in use. Everything below that location in stack is free. Pushing\n\t      a value onto the stack will invole decreasing the stack pointer and then writing\n\t      the value to the place that stack pointer pointes to. And popping a value do the\n\t      opposite.\n\t     \n\t      The ebp (base pointer) register, in contrast, is associated with the stack\n\t      primarily by software convention. On entry to a C function, the function's\n\t      prologue code normally saves the previous function's base pointer by pushing\n\t      it onto the stack, and then copies the current esp value into ebp for the duration\n\t      of the function. If all the functions in a program obey this convention,\n\t      then at any given point during the program's execution, it is possible to trace\n\t      back through the stack by following the chain of saved ebp pointers and determining\n\t      exactly what nested sequence of function calls caused this particular point in the\n\t      program to be reached. This capability can be particularly useful, for example,\n\t      when a particular function causes an assert failure or panic because bad arguments\n\t      were passed to it, but you aren't sure who passed the bad arguments. A stack\n\t      backtrace lets you find the offending function.\n\t     \n\t      The inline function read_ebp() can tell us the value of current ebp. And the\n\t      non-inline function read_eip() is useful, it can read the value of current eip,\n\t      since while calling this function, read_eip() can read the caller's eip from\n\t      stack easily.\n\t     \n\t      In print_debuginfo(), the function debuginfo_eip() can get enough information about\n\t      calling-chain. Finally print_stackframe() will trace and print them for debugging.\n\t     \n\t      Note that, the length of ebp-chain is limited. In boot/bootasm.S, before jumping\n\t      to the kernel entry, the value of ebp has been set to zero, that's the boundary.\n\t      /\n\t    void\n\t    print_stackframe(void) {\n\t         / LAB1 YOUR CODE : STEP 1 /\n\t        / (1) call read_ebp() to get the value of ebp. the type is (uint32_t);\n\t          (2) call read_eip() to get the value of eip. the type is (uint32_t);\n\t          (3) from 0 .. STACKFRAME_DEPTH\n\t          (3.1) printf value of ebp, eip\n\t          (3.2) (uint32_t)calling arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4]\n\t          (3.3) cprintf(\"\n\t\");\n\t          (3.4) call print_debuginfo(eip-1)to print the C calling function name and line number, etc.\n\t          (3.5) popup a calling stackframe\n\t                    NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]\n\t                            the calling funciton's ebp = ss:[ebp]\n\t         /\n\t    }\n\t    ```\n    \n",
    "source":"网络",
    "answer":"    ```\n    void\n    print_stackframe(void) {\n         / LAB1 YOUR CODE : STEP 1 /\n         / (1) call read_ebp() to get the value of ebp. the type is (uint32_t);\n           (2) call read_eip() to get the value of eip. the type is (uint32_t);\n           (3) from 0 .. STACKFRAME_DEPTH\n              (3.1) printf value of ebp, eip\n              (3.2) (uint32_t)calling arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4]\n              (3.3) cprintf(\"\n\");\n              (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.\n              (3.5) popup a calling stackframe\n                     NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]\n                             the calling funciton's ebp = ss:[ebp]\n          /\n        uint32_t ebp = read_ebp(), eip = read_eip();\n        int i, j;\n        for (i = 0; ebp != 0 && i < STACKFRAME_DEPTH; i ++) {\n            cprintf(\"ebp:0x%08x eip:0x%08x args:\", ebp, eip);\n            uint32_t args = (uint32_t )ebp + 2;\n            for (j = 0; j < 4; j ++) {\n                cprintf(\"0x%08x \", args[j]);\n            }\n            cprintf(\"\n\");\n            print_debuginfo(eip - 1);\n            eip = ((uint32_t )ebp)[1];\n            ebp = ((uint32_t )ebp)[0];\n        }\n    }\n    ```\n\n",
    "type":"question_answer",
    "q_number":852
}